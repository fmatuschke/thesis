\setcounter{chapter}{4}
\chapter{\acs{3D-PLI} simulation}
\label{cha:sof:simulation}
%
Simulations of \ac{3D-PLI} have already shown their capabilities and could increase the level of understanding \cite{Dohmen2015,Menzel2015,Menzel2016,Menzel2020,Menzel2021,MenzelMaster,MenzelDissertation}.
The algorithm presented here for designing new collision-free fiber models allows for the first time to simulate the effect of scattering light without superimposed interference signals, which enables the understanding of scattering in the finite-difference time domain.
This enabled the understanding of scattering effects due to fiber bundle and crossing configurations as well as the transmission change for tilted fiber configurations \cite{MenzelDissertation,Menzel2020,Menzel2021}.
\par
% 
In the case of linear optics simulation, the optical system could be successfully simulated and the experimental results \cite{Dohmen2015,Menzel2016} could be reproduced.
However, the algorithm developed at that time is very computationally intensive and also very memory intensive due to the precomputations of a discretized tissue volume.
The foundations for a more efficient parallel algorithm for supercomputer use were developed in response \cite{Lucksch2016}.
However, the new tilt design of the LMP3D microscope led to an unnecessary duplication of calculations in the simulations, which could not be easily changed in the algorithm designed at that time.
Therefore, the algorithm was redesigned from scratch and rewritten.
Additionally, the fiber models presented here had to be incorporated as well.
Finally, the decision was made to switch to the M"{u}ller-Stokes calculation in order to also take polarization effects of filters into account.
\par
%
The simulation is divided into two consecutive parts: the volume discretizer and the simulation.
The discrete volume generator discretizes the virtual nerve fiber models onto a cartesian grid, which is then used to compute the light-matter interaction in the second step.
A parallelization technique with \ac{MPI} allows the volume to be partitioned among different \acp{CPU} or nodes.
Due to the tilting approach, the light vector in such a paralized volume must be able to leave the current volume of a single \ac{CPU} and traverse to the next volume/\ac{CPU}.
The computationally intensive algorithms are written in \cpp{} with a user-friendly wrapper function in \python{}.
This simulation algorithm as well as the optical characterization of the system and the inclination analysis are discussed in this chapter.
%
% 
% 
\section{Discrete volume generator}
\label{sec:dv_generator}
%
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.5\textwidth}
\inputtikz{gfx/simpli/disc_volume}

\caption{Discretized tissue volume: Its boundry is defined by a \ac{AABB}, which itself is defined by the lower and upper corner values $v_\mathit{min}$ and $v_\mathit{max}$.}
\label{fig:discVol}
\end{figure}
%
The idea of the simulation is to divide the necessary calculations into two consecutive parts. The first part is the calculation of a discretized tissue volume.
It represents a discrete, voxel model of the tissue.
This helps to drastically speed up the light-matter interaction of the next step (see \cref{sec:simulation}), at the cost of a large memory requirement.
\par
%
The discretized tissue volume represents a cuboid divided into smaller cubes of equal size, called voxels, \ie{} 3d pixels (see \cref{fig:discVol}).
Each voxel contains the physical properties, absorption, birefringence and optical axis orientation, of the tissue at its current position.
The total volume is bounded by a \ac{AABB} or \ac{VOI} defined by a minimum and maximum value $\voi = [(x_{\mathit{min}}, y_{\mathit{min}}, z_{\mathit{min}}), (x_{\mathit{max}}, y_{\mathit{max}}, z_{\mathit{max}})]$.
Additionally, the \voxelsize{} parameter \voxelsize{} is set to a floating point number and defines the edge length of the voxels.
If the division of \voi{} by \Voxelsize{} is not an integer, \voi{} is automatically incremented to the nearest possible integer value to avoid edge effects.
%
%
%
\subsection{Nerve fiber layers}
%
As described in \cref{sec:fiberArchitecture}, nerve fibers are axons that can be wrapped by multiple turns of myelin (see \cref{fig:fiberLayer}).
Especially for light wave simulations, the myelin windings are an important feature \cite{MenzelDissertation}.
This makes it necessary to be able to build such a structure.
\par
%
A simple implementation is to represent the windings as layers (see \cref{fig:myelinLayer}).
This greatly simplifies the creation process.
A layer can then be simply defined by a factor between $\SI{0}{}$ and $\SI{1}{}$ that scales with the radius of the nerve fiber.
For example, $\SI{0.75}{}$ means that from $0 \leq r < 0.75$ of radii is interpreted as the first layer (see \cref{fig:fiberLayer}).
\par
%
Each layer also requires a number of physical properties in addition to its radius:
%
\begin{itemize}[nosep]
    \item birefringence value $\dn$
    \item absorption coefficient $\mu$
    \item optical axsis model $p=\mathit{parallel}$, $r=\mathit{radial}$, $b=\mathit{background}$
\end{itemize}
%
These properties are specified as a list of tuples within the algorithm (see \cref{alg:fiberbundleprops}).
%
\begin{lstfloat}[!ht]
\lstset{style=python}
\begin{lstlisting}[]
fbs_properties = [[(r, dn, mu, 'p'), (second layer), ...],
                  [(first layer of second bundle), ...],
                  [...]]
\end{lstlisting}
\caption{Definition of the properties of fiber bundles.}
\label{alg:fiberbundleprops}
\end{lstfloat}
%
At the end, the DV generator returns the arrays \tissue{}, \opticalaxis{} and \propertylist{} for use in the simulation.
Since the arrays are quite large, the transfer is performed using a \name{numpy-array} without having to copy the data.
% 
% 
%
\subsection{Discretization of a nerve fiber model}
%
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.32\textwidth}
\subcaptionbox{\label{fig:myelinLayer}Schematic representation of a nerve fiber with axon and myelin sheath}[.32\textwidth]{
\includegraphics[height=0.3\textwidth]{dev/brain/myelin_layers.pdf}\vspace{0mm}}\hfill
\subcaptionbox{\label{fig:fiberLayer}Cross section through a nerve fiber with layered structure defined by $n$ radii}[.32\textwidth]{
\inputtikz{gfx/simpli/fiber_layer}\vspace{-5mm}}\hfill
\subcaptionbox{\label{fig:vectormodel}Cross section of a discretized nerve fiber with resulting optical axis vectors}[.32\textwidth]{
\inputtikz{gfx/simpli/vector_model}\vspace{-5mm}}
\caption{Discretization of nerve fibers with layered structure.}
\label{fig:fiber_discretisation}
\end{figure}
%
To discretize nerve fiber models (see \cref{chap:sof:modeling}), one can start by discretizing a single nerve fiber segment, since a fiber is a chain of consecutive segments.
The idea is that a voxel located within a fiber segment is labeled as a tissue with the physical properties (absorption, optical axis, and birefringence) starting at the voxel center position $\vec{q}$ (see \cref{fig:fiber_discretization}).
In this context, \say{a voxel within a fiber segment} means that its center lies within the volume of the fiber segment.
The discretized mesh is such that the array position $[i,j,k]$ occupies the space from $(i,j,k)$ to $(i+1,j+1,k+1)$ in the unit of \Voxelsize{}.
\par
%
Therefore, the filling process can be integrated by looping over all voxels in the current volume.
However, since a single nerve fiber segment is usually much smaller than the volume, it is useful to reduce the size of the iterating voxels.
This can be easily accomplished by iterating over only the voxels of the \ac{AABB} of the nerve fiber segment.
\par
%
Now, for each voxel, it is checked whether it is inside the nerve fiber segment.
This is computed analogously to the collision between two nerve fiber segments (see \cref{alg:pseudocodeCollisionDetection}), except that only one point of the shortest distance has to be found.
The other is the position of the voxel center $\vec{q}$.
From this calculation, not only the nearest points $\vec{p}_a$ and $\vec{p}_b$ are returned, but also the distance vector $\vec{d}$.
This helps to calculate the distance, which is used to check whether the voxel is inside the fiber segment, and if so, in which layer of the fiber segment it is located.
In addition, the distance vector calculation $\vec{d}$ is used when the optical axis within the current layer is set to a microscopic model. Then the optical axis is oriented radially to the fiber segment.
\par
%
In case of a valid entry, two values must be stored.
The first one is an index within an array \name{tissue} which will be used later to retrieve the properties from a list with the same index order.
The second entry is the orientation of the optical axis within the current layer.
The orientation is either parallel to the fiber segment in the case of the macroscopic model, or radial in the case of the microscopic model.
A layer can also be marked as \say{background}, allowing the user to specify an area with absorption but no birefringence.
\par
%
Before the loop traverses all fiber segments, another problem must be solved.
Since two consecutive fiber segments occupy the same space because they have a common point, they also fill the voxel of the tissue volume.
This is a problem because now the second fiber segment overwrites the values of the first.
This can be easily solved by adding an additional array that stores the smallest distance calculated when filling the voxel space.
The values are now overwritten when a new distance is calculated that is smaller than the one already stored.
This also solves the problem that in a radial optical axis model, the optical axis would be star-shaped at the end points of a fiber segment inside the fiber.
\par
%
The now completed loop is represented in the pseudocode \cref{alg:fillVolume}.
%
\begin{lstfloat}[!tb]
\lstset{style=python}
\begin{lstlisting}[]
for fiber_segment in fiber_bundle:
    for i,j,k in fiber_segment.aabb().voxels():
        min_dist, min_point = calculate_min_distance((i,j,k), cc)
        if min_dist < cc.radius:
            if min_dist < current_distance[i,j,k]:
                optical_axis[i,j,k,:] = get_axis_orientation(
                                            (i,j,k), min_dist,
                                            min_point)
                tissue[i,j,k] = get_layer_id(min_dist)
                current_distance[i,j,k] = min_dist
\end{lstlisting}
\caption{Pseudocode for filling the discretized volume.}
\label{alg:fillVolume}
\end{lstfloat}
%
The length of the optical axis vector is interpreted as strength.
In this model, the length is normally $\SI{1}{}$.
If the user wants to add variability, one can do so by changing the length of the vectors in the entries.
%
%
%
\subsection{\Voxelsize}
%
\begin{figure}[!t]
\centering
% \tikzset{external/export=false}
\setlength{\tikzwidth}{.24\textwidth}
\input{gfx/simpli/vector_error}
\caption{Discretization error. Cross-section through a single fiber with a myelin layer in the discretized tissue volume. The colored pattern shows the resulting voxels corresponding to the fiber. The smaller the \Voxelsize, the smaller the discretization error.}
\label{fig:vectorfield_disc_error}
\end{figure}
%
The parameter \Voxelsize{} is the most important property of the simulation.
It determines how accurate the simulation is.
This is because it changes the number of voxels used to discretize the nerve fiber model (see \cref{fig:vectorfield_disc_error}).
This has a large impact, especially in the case of multiple layers.
It also changes the step size of the light through the tissue.
Usually the \Stepsize is the same as the \Voxelsize, but the user can change it if needed.
Also, the number of light particles increases as \Voxelsize{} decreases, since a single light particle is cast for every voxel at the bottom of the tissue (see \cref{sec:pathOfLight}).
Therefore, the resulting intensity signal will also be more accurate.
%
%
% 
\subsection{Optimizations}\label{sec:dvOpti}
%
All arrays are implemented as contiguous c-arrays, accessible externally as \name{numpy-arrays} without the need to copy the data.
Since these arrays grow with $\mathcal{O}(n^3)$, the goal was to make them movable in both the \cpp{} libraries and \python{}.
The memory order of the arrays is in the $x\text{-}y\text{-}z$ direction, so the largest memory shift is in $x$ and the smallest in $z$.
This was chosen so that later in the simulation part, where the light moves mainly in the $z$ direction, the memory is aligned with the traversed information and thus the \acp{CPU} cache prefetcher can be used.
\par
%
Two methods are used to parallelize the algorithm on the \ac{CPU}.
The first uses \ac{OpenMP} to parallelize the filling of the \ac{AABB} volume of each object.
The second uses \ac{MPI} to allow distribution across multiple \ac{CPU} cores without sharing memory (detailed description in \cref{sec:mpiSim}).
\par
%
Parallelizing the filling of the voxels of the discretized volume leads to a race condition when multiple threads want to write or read to the same memory address (or coordinate) (\eg{} two objects occupy the same space).
A solution with a lock would be very slow and since many of the voxels do not need to be overwritten, most of the locks would be unnecessary.
Since the loop runs over all $(i,j,k)$ indices of the three spatial dimensions, parallelization can be done by iterating over the voxels themselves per fiber segment.
However, this leads to a slow implementation since new threads have to be created for each fiber segment, which takes quite a bit of time.
It was therefore decided that the parallel call would create all threads before the first loop over all objects.
This means that all threads process all objects.
When the threads then loop over all indexes (or coordinates), thread $n$ processes only the memory for the first volume dimension $i$ if (see \cref{fig:discVolThread}):
%
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.5\textwidth}
\inputtikz{gfx/simpli/disc_volume_thread}
\caption{Discretization volume parallelization with \ac{OpenMP}. Each thread processes every $n$-th $yz$-section. This ensures both thread safety and a more balanced workload, even under inhomogeneous conditions.}
\label{fig:discVolThread}
\end{figure}
%
\begin{align}
\begin{split}
    i \bmod N_{\mathit{Threads}} == \mathit{thread}_{\mathit{id}}
\end{split}
\end{align}
%
This procedure leads to a thread-safe writable operation.
The only drawback is that all threads must check whether the \ac{AABB} is inside the \ac{VOI}.
However, since the threads are spawned only one time in this configuration and the collision checking of \ac{AABB} is very efficient in terms of computation time, it is quite fast.
In addition, the shared cache of \acp{CPU} can speed up the memory fetch if the workload of \acp{CPU} is not too different.
% 
% \paragraph{Note} -> see results
% Depending on the size of the volume and available memory, the user is recommended to distribute the parallelization of \ac{OpenMP} to one node and the distribution of \ac{MPI} to multiple nodes. Depending on the architecture, the distribution cannot be easily optimized. Individual tests should be performed.
% The \ac{OpenMP} speedup is usually fastest when the spawend threads are on the same physical \ac{CPU} or even within the same \acp{CPU} that uses the same cache.
% Therefore, speedup may be increased by decreasing the \ac{OpenMP} threads and increasing the \ac{MPI} threads instead.
%
%
%
\section{Simulation}
\label{sec:simulation}
%
The simulation algorithm performs the Mueller-Stokes calculation (see \cref{sec:Mueller-Stokes}) on the previously calculated discrete volume (see \cref{sec:dv_generator}) for a light ray along its path.
Since no scattering or refraction effects are considered in this simulation, each light path follows a straight line.
Initially, the light vector is multiplied by the first polarizer of the optical system.
The interaction of light matter is calculated according to $\left( \prod_i R_i M_i R_i \cdot \vec{S} \right)$ (see \cref{sec:mueller_stokes}).
After the light beam reaches the end of the tissue, the last optical elements are considered.
Finally, the light intensity is stored in the \acs{CCD} image array, which at this point has the same size as the 2d $xy$ grid of the discretized tissue.
At the end, convolution is applied to blur the image, then the image is resampled to the final size of the \ac{CCD} array, and finally the noise model is applied.
%
%
\subsection{Path of light}
\label{sec:pathOfLight}
%
\begin{figure}[!t]
\setlength{\tikzheight}{0.42\textwidth}
\subcaptionbox{camera view}[.49\textwidth]{
\inputtikz{gfx/simpli/tilting_3d_a}}\hfill
\subcaptionbox{perspective view}[.49\textwidth]{
\inputtikz{gfx/simpli/tilting_3d_b}}
\tikzset{external/export=false}
\caption[3d tilting]{3d tilting: around $xy$-axis, \raisebox{.25em}{\tikz \draw[red,thick](0,0)--(0.25,0);} top, \raisebox{.25em}{\tikz \draw[green,thick](0,0)--(0.25,0);} middle, \raisebox{.25em}{\tikz \draw[blue,thick](0,0)--(0.25,0);} bottom, \raisebox{.25em}{\tikz \draw[dash pattern=on 1.25pt off 1.25pt,thick](0,0)--(0.25,0);} original, \raisebox{.25em}{\tikz \draw[gray](0,0)--(0.25,0);} axis of rotation.}
\label{fig:tilting_camera_view}
\end{figure}
%
The simulation allows for a tilting light beam.
For this purpose, the \ac{LAP} uses a tilting stage to which the tissue sections are attached (see \cref{fig:tilted_side_view}).
The newly designed microscope, on the other hand, has an already tilted light beam.
This is achieved by a conical light path, from which an aperture is then used to sample the desired light direction \cite{Wiese:887678}.
Both methods give the same light paths in good approximation.
\par
%
The tilting can lead to a distortion of the image (see \cref{fig:tilting_camera_view}).
This distortion can be described by an affine transformation (see \cref{fig::affine_transformation}):
%
\begin{figure}[!t]
\centering
\input{gfx/pli/affine_transformation}
\caption{affine transformation}
\label{fig::affine_transformation}
\end{figure}
%
\begin{align}
f(\vec{x}) = \mat{A} \cdot \vec{x} + \vec{t}
\end{align}
where $\vec{x}$ is the coordinate input, $\mat{A}$ and $\vec{t}$ are the transformation values, and $f(\vec{x}$ is the transformed coordinate.
\par
%
The simulation is able to account for the distorted view and can resample the initial positions of the light rays so that the distortion is reversed.
This is the same as the distortion of the \ac{CCD} sensor, but without the need for interpolation of the \ac{CCD} image sensor.
In the case of simulation of the distortion, the in the 
\ac{fastPLI} software provided affine inverse transform $f^{-1}(\vec{x}) = \mat{A}^{-1} \cdot \vec{x} - \vec{t}$ can be applied.
Since this leads to interpolation artifacts, both techniques are available to investigate this effect in more detail.
\par
%
An additional effect is the simulation of refraction at the tissue-air boundary, which is described by Snell's law for isotropic media (see \cref{eq:Snellius}).
Since this only adds a parallel shift, simulation is only necessary when the resampling of an image registration is to be investigated.
\par
%
\begin{figure}[!t]
\setlength{\tikzwidth}{0.42\textwidth}
\subcaptionbox{normal}[.495\textwidth]{
\def\tilt{0}
\def\nindex{2.25}
\inputtikz{gfx/simpli/tilting_a}}\hfill
\subcaptionbox{tilted}[.495\textwidth]{
\inputtikz{gfx/simpli/tilting_b}}
\caption[Light path]{Light path for a normal (a) and a tilted (b) case. In the tilted case, the light beam $\vec{l}_1$ is tilted within the tissue and thus experiences an optical shift $\Delta$.}
\label{fig:tilted_side_view}
\end{figure}
%
The initial position of the light beam is calculated by traversing the light path backwards (see \cref{fig:tilted_side_view}).
Each light beam $\vec{l}_0$ ends in the center of a \ac{CCD} array. 
From there, it can be shifted back to the plane of the tissue top $\mathfrak{S}_{top}$.
Subsequently, the light beam $\vec{l}_1$ is traced back through the tissue to the lower plane $\mathfrak{S}_{bottom}$.
The point on the lower tissue plane corresponds to the initial position of the light beam.
In the case of a tilted light beam or tilted tissue, there is an offset along the tilting direction $\theta$ of $\delta$.
By tracing the light from the \ac{CCD}-array to the tissue, resampling is avoided so that no edge effects can occur.
\par
%
\begin{lstfloat}[!p]
	\lstinputlisting[style=cpp,basicstyle=\scriptsize\ttfamily,]{code/simulation.cpp}
	\caption{Pseudocode simulation \todo{anhang}}
	\label{alg:simulation}
\end{lstfloat}
%
\subsection{Tissue voxel interpolation}
%
If the \Stepsize is not equal to the \Voxelsize or if the light path is tilted, the light path points no longer matches the center of the voxels.
This means that the physical properties stored in the arrays have to be interpolated.
%
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.45\textwidth}
% \tikzset{external/force remake=true}
\subcaptionbox{\label{fig:triInterp}Trilinear interpolation}[\tikzwidth]{
\hfill\inputtikz{gfx/simpli/trilinear_interpolation}\hfill}\hfill
\subcaptionbox{\label{fig:sphInterp}Spherical interpolation}[\tikzwidth]{
\inputtikz{gfx/simpli/vector_interpolation}}
\caption{Interpolation techniques: Trilinear interpolation can be represented as an axial step interpolation. The difference between linear and spherical interpolation is that linear interpolation has a constant distance $s$ between each point, while spherical interpolation has a constant angle $\varphi$ between two steps.}
\label{fig:vectorfield_disc}
\end{figure}
%
There are currently three interpolation methods for this purpose implemented: \textit{nearest neighbor}, \textit{linear interpolation} and \textit{spherical interpolation}.
The voxels taken into account for the interpolation are the nearest 8 adjacent voxels, so array indices $(\floor{x\pm0.5},\floor{y\pm0.5},\floor{y\pm0.5})$.
%
The \textit{nearest neighbor} is the most error-prone of the three methods and should be not to be used.
However it is also the fastest method.
The \textit{linear interpolation} was the first one implemented.
However since the data contain orientation data, the \textit{spherical interpolation} method should be used.
\par
%
To interpolate the data the trilinear interpolation will be performed (see \cref{fig:triInterp}).
%
%
%
\subsection{algorithm}
%
First the starting points of all light beams will be calculated.
hen each light beam can be traversed inside the tissue.
To calculate the light matter interaction, the change of the Stokes vector will be calculated after each light beam step.
As soon as the light hits the boarder of the tissue, the light beam will be the last optical elements and the intensity will be stored inside the \ac{CCD} array.
The pseudocode is shown in \cref{alg:simulationLoop}.
%
\begin{lstfloat}[!tb]
\lstset{style=python}
\begin{lstlisting}[]
light_beams = calculate_light_starting_positions()

for light in light_beams:
    light = optical_elemts_start * light
    while light.pos in volume:
        properties = get_properties(light.pos)
        light.intensity *= exp(-step_size * properties.absorbtion)
        light = matrix(properties) * light
        light.pos += step_size
   
    light = optical_elemts_end * light
    ccd_array[light.ccd_pos] = light.intensity
\end{lstlisting}
\caption{Discretized volume filling algorithm}
\label{alg:simulationLoop}
\end{lstfloat}
%
%
%
\subsection{Optimizations}
%
There are several optimizations used inside this pipeline.
First the order of the tissue stored inside the memory is along the z-axis (as described in \cref{sec:dvOpti}).
Secondly the main for loop for each light ray is parallized with \ac{OpenMP}.
This threads are completely separated and no race conditions exists.
%
%
%
\subsection{Optic}
\label{sec:ccdOptic}
%
The image sensor as described in \cref{sec:expSetup} is a \ac{CCD} sensor.
The calculations, \ie the resampling and noise modelling, are implemented according to \cref{sec:opticalResolution}.
These calculations are performed on the python side of the algorithm and can be parallized with the \code{multiprocessing} library of \python{}.
%
% A general \ac{CCD} sensor consits out of an array of capacitors.
% In each capacitor an electric charge will be stored, setted free by an incoming photons.
% After a read out process, which also contains a electric gain, the resulting values can be stored as an image.
% This process has two major noise parts. The first is the electic charge.
% Its value is, as long as it is not saturated, linear correlated with the number of photons.
% However internal noise like thermal, and a each photon statistically charges a number of electrons, the resulting capacity varies.
% The second major noise comes from the gain process.
% Here the electric voltage will be gained before a analog digital read out.
% This process is also strong linear correlated around a operational point.
% However due to the nature of the underlining circuit, i.e. usually transistors and their power source, the resulting value can vary.
% All noise sources combined yield to an poison distributed noise, to too the nature of digital values.
%
% \\
%
% To account for the optical setup, three things have to be done.
% \paragraph{Bluring}
% The optical resolution the light rays have to be blurred.
% This is classically done via a 2d gaussian convolution:
%
% \paragraph{Sampling}
% Since the number and final position of the light rays is according to the voxels, all intensities of an image pixel have to be combined.
% Here it is done via a mean value sampling.
% This in contrast to resizing, does not interpolates the image.
% %
% \paragraph{Noise}
% The last step is to replicate the noise of the image setup. To account for this a noise model has to be applied to each image pixel. \cite{Wiese:887678} showed that this can be done via a poisson/gaus model.
%
%
%
\section{Analysis}
%
The same algorithms are implemented as in the \ac{3D-PLI} routine pipeline (see \cref{sec::intSignal,sec::InclAnalysis}).
This include the modalities analysis transmittance, direction and retardatation as well as the tilting analysis performend by \ac{ROFL}.
%
%
%
\section{MPI parallelization}\label{sec:mpiSim}
%
Both algorithms, the DV generator and the simulation can use an additionally parallelization technique.
%
For huge volumes that are larger than the locally memory size, the calculation must be split onto several physical \acp{CPU} and \name{computation nodes}\footnote{A computing node is a processing unit in a computer network}.
For this purpose \acreset{MPI} \ac{MPI} is used.
A method is implemented that automatically divides the volume along the $x$-axis and $y$-axis into blocks with minimal surface area (see \cref{fig:com_halo}).
The minimization of the $x-y$-surface area is important for the simulation algorithm.
\par
Once the volume is split into euqal parts, with respect to the nature of integers, the above mentioned algorithms can be performend completly analog on the \ac{MPI} ranks, as if they only would know about there volume.
The only exception is the simulation for tilted light beams.
This means, that at the boarder of the volume, when a light beam travels through the tissue, the light can leave the local volume of the \ac{MPI} rank.
\ac{MPI} provides several methods to send information to another rank.
Since this volume splitting is cartesion, the cartesion implementations of \ac{MPI} are used (\eg{} \code{MPI\tu Cart\tu create}).
However since the light beam also needs in the case of interpolation the information of the surrounding $\SI{8}{\voxel}$, this would mean that the missing voxels had to be transferred to the neighboring ranks.
%
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.85\textwidth}
\inputtikz{gfx/simpli/com_halo}
\caption{comunication halos. The volume is split into six subvolumes, distributed to 6 mpi ranks. The coloured voxels have the same tissue information.  To calculate the value at a given point a eight-neighborhood is necessary.}
\label{fig:com_halo}
\end{figure}
%
This would mean a huge amount of communications, which are relatively slow.
The solution is a so called \name{halo}.
This is a commonly used concept, where the borders (in this case a volume) are enlarged by a a specific size (in this case $\SI{1}{\voxel}$) so that the same information of the shared regions is available everywhere (see \cref{fig:com_halo}).
%
% \begin{figure}[!t]
% \centering
% \def\tikzwidth{0.5\textwidth}
% \inputtikz[]{gfx/simpli/com_halo_send}
% \caption{Light ray send to another node. To calculate the \dummy{} a eight-neighborhood is necessary.}
% \label{fig:com_halo_light}
% \end{figure}
Now the light beam can be communicated when it leaves the local volume to the next one (see \cref{fig:com_halo}).
This is also the reason, why the surface area is minimized, so that the number of communications is also minimized.
\par
To even more speed up the communication process, all leaving light beams are first stored locally in a communication buffer, and only after all local light beams were processed, the buffer will be communicated to the neighbors.
This ensure a minimal communication cost.
The main light beam algorithm loop is then started again on all \ac{MPI} ranks for the communicated light beams.
This is repeated until no more communications were necessary.
\par
%
Each \ac{MPI} process can additionally use \ac{OpenMP} to create multiple threads for efficient use of shared memory if the architecture supports it.
% 
%