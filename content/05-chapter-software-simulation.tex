\setcounter{chapter}{4}
\chapter{\acs{3D-PLI} simulation}
\label{cha:sof:simulation}
%
Simulations of \ac{3D-PLI} have already shown their capabilities and could increase the level of understanding \cite{Dohmen2015,Menzel2015,Menzel2016,Menzel2020,Menzel2021,MenzelMaster,MenzelDissertation}.
The algorithm presented here for designing new collision-free fiber models allows for the first time to simulate the effect of scattering light without superimposed interference signals, which enables the understanding of scattering in the finite-difference time domain.
This enabled the understanding of scattering effects due to fiber bundle and crossing configurations as well as the transmission change for tilted fiber configurations \cite{MenzelDissertation,Menzel2020,Menzel2021}.
\par
% 
In the case of linear optics simulation, the optical system could be successfully simulated and the experimental results \cite{Dohmen2015,Menzel2016} could be reproduced.
However, the algorithm developed at that time is very computationally intensive and also very memory intensive due to the precomputations of a discretized tissue volume.
The foundations for a more efficient parallel algorithm for supercomputer use were developed in response \cite{Lucksch2016}.
However, the new tilt design of the LMP3D microscope led to an unnecessary duplication of calculations in the simulations, which could not be easily changed in the algorithm designed at that time.
Therefore, the algorithm was redesigned from scratch and rewritten.
Additionally, the fiber models presented here had to be incorporated as well.
Finally, the decision was made to switch to the M"{u}ller-Stokes calculation in order to also take polarization effects of filters into account.
\par
%
The simulation is divided into two consecutive parts: the volume discretizer and the simulation.
The discrete volume generator discretizes the virtual nerve fiber models onto a cartesian grid, which is then used to compute the light-matter interaction in the second step.
A parallelization technique with \ac{MPI} allows the volume to be partitioned among different \acp{CPU} or nodes.
Due to the tilting approach, the light vector in such a paralized volume must be able to leave the current volume of a single \ac{CPU} and traverse to the next volume/\ac{CPU}.
The computationally intensive algorithms are written in \cpp{} with a user-friendly wrapper function in \python{}.
This simulation algorithm as well as the optical characterization of the system and the inclination analysis are discussed in this chapter.
%
% 
% 
\section{Discrete volume generator}
\label{sec:dv_generator}
%
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.5\textwidth}
\inputtikz{gfx/simpli/disc_volume}

\caption{Discretized tissue volume: Its boundry is defined by a \ac{AABB}, which itself is defined by the lower and upper corner values $v_\mathit{min}$ and $v_\mathit{max}$.}
\label{fig:discVol}
\end{figure}
%
The idea of the simulation is to divide the necessary calculations into two consecutive parts. The first part is the calculation of a discretized tissue volume.
It represents a discrete, voxel model of the tissue.
This helps to drastically speed up the light-matter interaction of the next step (see \cref{sec:simulation}), at the cost of a large memory requirement.
\par
%
The discretized tissue volume represents a cuboid divided into smaller cubes of equal size, called voxels, \ie{} 3d pixels (see \cref{fig:discVol}).
Each voxel contains the physical properties, absorption, birefringence and optical axis orientation, of the tissue at its current position.
The total volume is bounded by a \ac{AABB} or \ac{VOI} defined by a minimum and maximum value $\voi = [(x_{\mathit{min}}, y_{\mathit{min}}, z_{\mathit{min}}), (x_{\mathit{max}}, y_{\mathit{max}}, z_{\mathit{max}})]$.
Additionally, the \voxelsize{} parameter \voxelsize{} is set to a floating point number and defines the edge length of the voxels.
If the division of \voi{} by \Voxelsize{} is not an integer, \voi{} is automatically incremented to the nearest possible integer value to avoid edge effects.
%
%
%
\subsection{Nerve fiber layers}
%
As described in \cref{sec:fiberArchitecture}, nerve fibers are axons that can be wrapped by multiple turns of myelin (see \cref{fig:fiberLayer}).
Especially for light wave simulations, the myelin windings are an important feature \cite{MenzelDissertation}.
This makes it necessary to be able to build such a structure.
\par
%
A simple implementation is to represent the windings as layers (see \cref{fig:myelinLayer}).
This greatly simplifies the creation process.
A layer can then be simply defined by a factor between $\SI{0}{}$ and $\SI{1}{}$ that scales with the radius of the nerve fiber.
For example, $\SI{0.75}{}$ means that from $0 \leq r < 0.75$ of radii is interpreted as the first layer (see \cref{fig:fiberLayer}).
\par
%
Each layer also requires a number of physical properties in addition to its radius:
%
\begin{itemize}[nosep]
    \item birefringence value $\dn$
    \item absorption coefficient $\mu$
    \item optical axsis model $p=\mathit{parallel}$, $r=\mathit{radial}$, $b=\mathit{background}$
\end{itemize}
%
These properties are specified as a list of tuples within the algorithm (see \cref{alg:fiberbundleprops}).
%
\begin{lstfloat}[!ht]
\lstset{style=python}
\begin{lstlisting}[]
fbs_properties = [[(r, dn, mu, 'p'), (second layer), ...],
                  [(first layer of second bundle), ...],
                  [...]]
\end{lstlisting}
\caption{Definition of the properties of fiber bundles.}
\label{alg:fiberbundleprops}
\end{lstfloat}
%
At the end, the DV generator returns the arrays \tissue{}, \opticalaxis{} and \propertylist{} for use in the simulation.
Since the arrays are quite large, the transfer is performed using a \name{numpy-array} without having to copy the data.
% 
% 
%
\subsection{Discretization of a nerve fiber model}
%
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.32\textwidth}
\subcaptionbox{\label{fig:myelinLayer}Schematic representation of a nerve fiber with axon and myelin sheath}[.32\textwidth]{
\includegraphics[height=0.3\textwidth]{dev/brain/myelin_layers.pdf}\vspace{0mm}}\hfill
\subcaptionbox{\label{fig:fiberLayer}Cross section through a nerve fiber with layered structure defined by $n$ radii}[.32\textwidth]{
\inputtikz{gfx/simpli/fiber_layer}\vspace{-5mm}}\hfill
\subcaptionbox{\label{fig:vectormodel}Cross section of a discretized nerve fiber with resulting optical axis vectors}[.32\textwidth]{
\inputtikz{gfx/simpli/vector_model}\vspace{-5mm}}
\caption{Discretization of nerve fibers with layered structure.}
\label{fig:fiber_discretisation}
\end{figure}
%
To discretize nerve fiber models (see \cref{chap:sof:modeling}), one can start by discretizing a single nerve fiber segment, since a fiber is a chain of consecutive segments.
The idea is that a voxel located within a fiber segment is labeled as a tissue with the physical properties (absorption, optical axis, and birefringence) starting at the voxel center position $\vec{q}$ (see \cref{fig:fiber_discretization}).
In this context, \say{a voxel within a fiber segment} means that its center lies within the volume of the fiber segment.
The discretized mesh is such that the array position $[i,j,k]$ occupies the space from $(i,j,k)$ to $(i+1,j+1,k+1)$ in the unit of \Voxelsize{}.
\par
%
Therefore, the filling process can be integrated by looping over all voxels in the current volume.
However, since a single nerve fiber segment is usually much smaller than the volume, it is useful to reduce the size of the iterating voxels.
This can be easily accomplished by iterating over only the voxels of the \ac{AABB} of the nerve fiber segment.
\par
%
Now, for each voxel, it is checked whether it is inside the nerve fiber segment.
This is computed analogously to the collision between two nerve fiber segments (see \cref{alg:pseudocodeCollisionDetection}), except that only one point of the shortest distance has to be found.
The other is the position of the voxel center $\vec{q}$.
From this calculation, not only the nearest points $\vec{p}_a$ and $\vec{p}_b$ are returned, but also the distance vector $\vec{d}$.
This helps to calculate the distance, which is used to check whether the voxel is inside the fiber segment, and if so, in which layer of the fiber segment it is located.
In addition, the distance vector calculation $\vec{d}$ is used when the optical axis within the current layer is set to a microscopic model. Then the optical axis is oriented radially to the fiber segment.
\par
%
In case of a valid entry, two values must be stored.
The first one is an index within an array \name{tissue} which will be used later to retrieve the properties from a list with the same index order.
The second entry is the orientation of the optical axis within the current layer.
The orientation is either parallel to the fiber segment in the case of the macroscopic model, or radial in the case of the microscopic model.
A layer can also be marked as \say{background}, allowing the user to specify an area with absorption but no birefringence.
\par
%
Before the loop traverses all fiber segments, another problem must be solved.
Since two consecutive fiber segments occupy the same space because they have a common point, they also fill the voxel of the tissue volume.
This is a problem because now the second fiber segment overwrites the values of the first.
This can be easily solved by adding an additional array that stores the smallest distance calculated when filling the voxel space.
The values are now overwritten when a new distance is calculated that is smaller than the one already stored.
This also solves the problem that in a radial optical axis model, the optical axis would be star-shaped at the end points of a fiber segment inside the fiber.
\par
%
The now completed loop is represented in the pseudocode \cref{alg:fillVolume}.
%
\begin{lstfloat}[!tb]
\lstset{style=python}
\begin{lstlisting}[]
for fiber_segment in fiber_bundle:
    for i,j,k in fiber_segment.aabb().voxels():
        min_dist, min_point = calculate_min_distance((i,j,k), cc)
        if min_dist < cc.radius:
            if min_dist < current_distance[i,j,k]:
                optical_axis[i,j,k,:] = get_axis_orientation(
                                            (i,j,k), min_dist,
                                            min_point)
                tissue[i,j,k] = get_layer_id(min_dist)
                current_distance[i,j,k] = min_dist
\end{lstlisting}
\caption{Pseudocode for filling the discretized volume.}
\label{alg:fillVolume}
\end{lstfloat}
%
The length of the optical axis vector is interpreted as strength.
In this model, the length is normally $\SI{1}{}$.
If the user wants to add variability, one can do so by changing the length of the vectors in the entries.
%
%
%
\subsection{\Voxelsize}
%
\begin{figure}[!t]
\centering
% \tikzset{external/export=false}
\setlength{\tikzwidth}{.24\textwidth}
\input{gfx/simpli/vector_error}
\caption{Discretization error. Cross-section through a single fiber with a myelin layer in the discretized tissue volume. The colored pattern shows the resulting voxels corresponding to the fiber. The smaller the \Voxelsize, the smaller the discretization error.}
\label{fig:vectorfield_disc_error}
\end{figure}
%
The parameter \Voxelsize{} is the most important property of the simulation.
It determines how accurate the simulation is.
This is because it changes the number of voxels used to discretize the nerve fiber model (see \cref{fig:vectorfield_disc_error}).
This has a large impact, especially in the case of multiple layers.
It also changes the step size of the light through the tissue.
Usually the \Stepsize is the same as the \Voxelsize, but the user can change it if needed.
Also, the number of light particles increases as \Voxelsize{} decreases, since a single light particle is cast for every voxel at the bottom of the tissue (see \cref{sec:pathOfLight}).
Therefore, the resulting intensity signal will also be more accurate.
%
%
% 
\subsection{Optimizations}\label{sec:dvOpti}
%
All arrays are implemented as contiguous c-arrays, accessible externally as \name{numpy-arrays} without the need to copy the data.
Since these arrays grow with $\mathcal{O}(n^3)$, the goal was to make them movable in both the \cpp{} libraries and \python{}.
The memory order of the arrays is in the $x\text{-}y\text{-}z$ direction, so the largest memory shift is in $x$ and the smallest in $z$.
This was chosen so that later in the simulation part, where the light moves mainly in the $z$ direction, the memory is aligned with the traversed information and thus the \acp{CPU} cache prefetcher can be used.
\par
%
Two methods are used to parallelize the algorithm on the \ac{CPU}.
The first uses \ac{OpenMP} to parallelize the filling of the \ac{AABB} volume of each object.
The second uses \ac{MPI} to allow distribution across multiple \ac{CPU} cores without sharing memory (detailed description in \cref{sec:mpiSim}).
\par
%
Parallelizing the filling of the voxels of the discretized volume leads to a race condition when multiple threads want to write or read to the same memory address (or coordinate) (\eg{} two objects occupy the same space).
A solution with a lock would be very slow and since many of the voxels do not need to be overwritten, most of the locks would be unnecessary.
Since the loop runs over all $(i,j,k)$ indices of the three spatial dimensions, parallelization can be done by iterating over the voxels themselves per fiber segment.
However, this leads to a slow implementation since new threads have to be created for each fiber segment, which takes quite a bit of time.
It was therefore decided that the parallel call would create all threads before the first loop over all objects.
This means that all threads process all objects.
When the threads then loop over all indexes (or coordinates), thread $n$ processes only the memory for the first volume dimension $i$ if (see \cref{fig:discVolThread}):
%
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.5\textwidth}
\inputtikz{gfx/simpli/disc_volume_thread}
\caption{Discretization volume parallelization with \ac{OpenMP}. Each thread processes every $n$-th $yz$-section. This ensures both thread safety and a more balanced workload, even under inhomogeneous conditions.}
\label{fig:discVolThread}
\end{figure}
%
\begin{align}
\begin{split}
    i \bmod N_{\mathit{Threads}} == \mathit{thread}_{\mathit{id}}
\end{split}
\end{align}
%
This procedure leads to a thread-safe writable operation.
The only drawback is that all threads must check whether the \ac{AABB} is inside the \ac{VOI}.
However, since the threads are spawned only one time in this configuration and the collision checking of \ac{AABB} is very efficient in terms of computation time, it is quite fast.
In addition, the shared cache of \acp{CPU} can speed up the memory fetch if the workload of \acp{CPU} is not too different.
% 
% \paragraph{Note} -> see results
% Depending on the size of the volume and available memory, the user is recommended to distribute the parallelization of \ac{OpenMP} to one node and the distribution of \ac{MPI} to multiple nodes. Depending on the architecture, the distribution cannot be easily optimized. Individual tests should be performed.
% The \ac{OpenMP} speedup is usually fastest when the spawend threads are on the same physical \ac{CPU} or even within the same \acp{CPU} that uses the same cache.
% Therefore, speedup may be increased by decreasing the \ac{OpenMP} threads and increasing the \ac{MPI} threads instead.
%
%
%
\section{Simulation}
\label{sec:simulation}
%
The simulation algorithm performs the Mueller-Stokes calculation (see \cref{sec:Mueller-Stokes}) on the previously calculated discrete volume (see \cref{sec:dv_generator}) for a light ray along its path.
Since no scattering or refraction effects are considered in this simulation, each light path follows a straight line.
Initially, the light vector is multiplied by the first polarizer of the optical system.
The interaction of light matter is calculated according to $\left( \prod_i R_i M_i R_i \cdot \vec{S} \right)$ (see \cref{sec:mueller_stokes}).
After the light beam reaches the end of the tissue, the last optical elements are considered.
Finally, the light intensity is stored in the \acs{CCD} image array, which at this point has the same size as the 2d $xy$ grid of the discretized tissue.
At the end, convolution is applied to blur the image, then the image is resampled to the final size of the \ac{CCD} array, and finally the noise model is applied.
%
%
\subsection{Path of light}
\label{sec:pathOfLight}
%
\begin{figure}[!t]
\setlength{\tikzheight}{0.42\textwidth}
\subcaptionbox{camera view}[.49\textwidth]{
\inputtikz{gfx/simpli/tilting_3d_a}}\hfill
\subcaptionbox{perspective view}[.49\textwidth]{
\inputtikz{gfx/simpli/tilting_3d_b}}
\tikzset{external/export=false}
\caption[3d tilting]{3d tilting: around $xy$-axis, \raisebox{.25em}{\tikz \draw[red,thick](0,0)--(0.25,0);} top, \raisebox{.25em}{\tikz \draw[green,thick](0,0)--(0.25,0);} middle, \raisebox{.25em}{\tikz \draw[blue,thick](0,0)--(0.25,0);} bottom, \raisebox{.25em}{\tikz \draw[dash pattern=on 1.25pt off 1.25pt,thick](0,0)--(0.25,0);} original, \raisebox{.25em}{\tikz \draw[gray](0,0)--(0.25,0);} axis of rotation.}
\label{fig:tilting_camera_view}
\end{figure}
%
The simulation allows for a tilting light beam.
For this purpose, the \ac{LAP} uses a tilting stage to which the tissue sections are attached (see \cref{fig:tilted_side_view}).
The newly designed microscope, on the other hand, has an already tilted light beam.
This is achieved by a conical light path, from which an aperture is then used to sample the desired light direction \cite{Wiese:887678}.
Both methods give the same light paths in good approximation.
\par
%
The tilting can lead to a distortion of the image (see \cref{fig:tilting_camera_view}).
This distortion can be described by an affine transformation (see \cref{fig::affine_transformation}):
%
\begin{figure}[!t]
\centering
\input{gfx/pli/affine_transformation}
\caption{affine transformation}
\label{fig::affine_transformation}
\end{figure}
%
\begin{align}
f(\vec{x}) = \mat{A} \cdot \vec{x} + \vec{t}
\end{align}
where $\vec{x}$ is the coordinate input, $\mat{A}$ and $\vec{t}$ are the transformation values, and $f(\vec{x}$ is the transformed coordinate.
\par
%
The simulation is able to account for the distorted view and can resample the initial positions of the light rays so that the distortion is reversed.
This is the same as the distortion of the \ac{CCD} sensor, but without the need for interpolation of the \ac{CCD} image sensor.
In the case of simulation of the distortion, the in the 
\ac{fastPLI} software provided affine inverse transform $f^{-1}(\vec{x}) = \mat{A}^{-1} \cdot \vec{x} - \vec{t}$ can be applied.
Since this leads to interpolation artifacts, both techniques are available to investigate this effect in more detail.
\par
%
An additional effect is the simulation of refraction at the tissue-air boundary, which is described by Snell's law for isotropic media (see \cref{eq:Snellius}).
Since this only adds a parallel shift, simulation is only necessary when the resampling of an image registration is to be investigated.
\par
%
\begin{figure}[!t]
\setlength{\tikzwidth}{0.42\textwidth}
\subcaptionbox{normal}[.495\textwidth]{
\def\tilt{0}
\def\nindex{2.25}
\inputtikz{gfx/simpli/tilting_a}}\hfill
\subcaptionbox{tilted}[.495\textwidth]{
\inputtikz{gfx/simpli/tilting_b}}
\caption[Light path]{Light path for a normal (a) and a tilted (b) case. In the tilted case, the light beam $\vec{l}_1$ is tilted within the tissue and thus experiences an optical shift $\Delta$.}
\label{fig:tilted_side_view}
\end{figure}
%
The initial position of the light beam is calculated by traversing the light path backwards (see \cref{fig:tilted_side_view}).
Each light beam $\vec{l}_0$ ends in the center of a \ac{CCD} array. 
From there, it can be shifted back to the plane of the tissue top $\mathfrak{S}_{top}$.
Subsequently, the light beam $\vec{l}_1$ is traced back through the tissue to the lower plane $\mathfrak{S}_{bottom}$.
The point on the lower tissue plane corresponds to the initial position of the light beam.
In the case of a tilted light beam or tilted tissue, there is an offset along the tilting direction $\theta$ of $\delta$.
By tracing the light from the \ac{CCD}-array to the tissue, resampling is avoided so that no edge effects can occur.
\par
%
\begin{lstfloat}[!p]
	\lstinputlisting[style=cpp,basicstyle=\scriptsize\ttfamily,]{code/simulation.cpp}
	\caption{Pseudocode simulation \todo{anhang}}
	\label{alg:simulation}
\end{lstfloat}
%
\subsection{Tissue voxel interpolation}
%
If the \Stepsize is not equal to the \Voxelsize or if the light path is tilted, the light path points no longer matches the center of the voxels.
This means that the physical properties stored in the arrays have to be interpolated.
%
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.45\textwidth}
% \tikzset{external/force remake=true}
\subcaptionbox{\label{fig:triInterp}Trilinear interpolation}[\tikzwidth]{
\hfill\inputtikz{gfx/simpli/trilinear_interpolation}\hfill}\hfill
\subcaptionbox{\label{fig:sphInterp}Spherical interpolation}[\tikzwidth]{
\inputtikz{gfx/simpli/vector_interpolation}}
\caption{Interpolation techniques: Trilinear interpolation can be represented as an axial step interpolation. The difference between linear and spherical interpolation is that linear interpolation has a constant distance $s$ between each point, while spherical interpolation has a constant angle $\varphi$ between two steps.}
\label{fig:vectorfield_disc}
\end{figure}
%
Currently three interpolation methods are implemented for this purpose: \name{nearest neighbor}, \name{linear interpolation} and \name{spherical interpolation}.
The voxels considered for interpolation are the nearest eight neighboring voxels, i.e. array indices $(\floor{x\pm0.5},\floor{y\pm0.5},\floor{y\pm0.5})$.
The \name{nearest neighbor} method is the most error-prone of the three methods and should not be used.
However, it is also the fastest method.
The \name{linear interpolation} is of the next higher order.
However, since the data contains orientation data, the \name{spherical interpolation} method should be used (see \cref{fig:triInterp}).
%
%
%
\subsection{Simulation of light-tissue interaction}
%
First, the starting points of all light beams are calculated.
Then, each light beam can be traversed within the tissue.
To calculate the light-tissue interaction, the change of the Stokes vector is calculated after each light beam step.
Once the light hits the boundary of the volume, the light beam is multiplied by the matrix of the last optical element and the intensity is stored in the \ac{CCD}-array.
The pseudocode is shown in \cref{alg:simulationLoop}.
%
\begin{lstfloat}[!tb]
\lstset{style=python}
\begin{lstlisting}[]
light_beams = calculate_light_starting_positions()

for light in light_beams:
    light = optical_elemts_start * light
    while light.pos in volume:
        properties = get_properties(light.pos)
        light.intensity *= exp(-step_size * properties.absorbtion)
        light = matrix(properties) * light
        light.pos += step_size
   
    light = optical_elemts_end * light
    ccd_array[light.ccd_pos] = light.intensity
\end{lstlisting}
\caption{Simulation of light-tissue interaction}
\label{alg:simulationLoop}
\end{lstfloat}
%
%
%
\subsection{Optimizations}
%
Several optimizations are made in this pipeline.
First, the order of the tissues stored in memory is along the z-axis (as described in \cref{sec:dvOpti}).
Second, the for loop for the light beams is paralellized with \ac{OpenMP}.
These threads are completely separated and there are no race conditions.
In addition, all vector and matrix calculations are optimized for their small sizes by the compiler with the help of tools like \name{Compiler Explorer}\footnote{\url{https://godbolt.org/}} and \name{C++ Insight}\footnote{\url{https://cppinsights.io/}}.
%
%
\section{Optical system and signal analysis}
\label{sec:ccdOptic}
%
The image sensor, as described in \cref{sec:expSetup}, is a \ac{CCD}-sensor.
The calculations, \ie the resampling and noise modeling, are implemented according to \cref{sec:opticalResolution}.
These calculations are performed on the \python{} side of the algorithm and can be executed with the \code{multiprocessing} library of \python{} to use multiple \ac{CPU} cores.
\par
%
The same algorithms are implemented as in the \ac{3D-PLI} routine pipeline (see \cref{sec::intSignal,sec::InclAnalysis}).
This include the modalities analysis transmittance, direction and retardatation as well as the inclination analysis performend by \ac{ROFL}.
%
%
%
\section{MPI parallelization}\label{sec:mpiSim}
%
Both algorithms, the DV generator and the LT simulation, can additionally use a parallelization technique.
For large volumes that are larger than the local memory size, the computation must be split among multiple physical \acp{CPU}s and \name{computation nodes}.
For this purpose, \acreset{MPI} \ac{MPI} is used.
A method is implemented to automatically partition the volume along the $x$-axis and the $y$-axis into blocks with minimal surface area (see \cref{fig:com_halo}).
% Minimizing the $xy$-area is important for the simulation algorithm.
\par
% 
Each CPU can be performed on its volume the above algorithms analogously on the \ac{MPI} \name{ranks} as if they knew only their volume.
The exception is the simulation for tilted light beams.
Here, when a light ray leaves the local volume, it must be transmitted to the adjacent volume.
\ac{MPI} provides several methods to send information to another \name{rank}.
Since this volume sharing is cartesion, the cartesion implementations of \ac{MPI} are used (\eg{} \code{MPI\tu Cart\tu create}).
%
\begin{figure}[!t]
    \centering
    \setlength{\tikzwidth}{0.85\textwidth}
    \inputtikz{gfx/simpli/com_halo}
    \caption{comunication halos. The volume is split into six subvolumes, distributed to 6 mpi ranks. The coloured voxels have the same tissue information.  To calculate the value at a given point a eight-neighborhood is necessary.}
    \label{fig:com_halo}
\end{figure}
%
A problem is the calculation at the edge of the volume, because the light beam needs the information of the surrounding eight voxels for the interpolation.
If this voxel information were to be transmitted to the neighboring \name{rank} as well, this would mean a large amount of communication, which is much slower compared to the local \ac{CPU} or \ac{RAM} instructions.
The solution is a so-called \name{halo}.
This is a commonly used concept where the boundaries (in this case a volume) are increased by a certain size (in this case $\SI{1}{\voxel}$) so that the same information about the shared regions is available everywhere (see \cref{fig:com_halo}).
\par
%
With this concept, only the light beam needs to be communicated to the neighbors when leaving the local volume (see \cref{fig:com_halo}).
This is also the reason why the surface area is minimized, so the number of communications is also minimized.
\par
% 
To further speed up the communication process, all outgoing light beams are first stored locally in a communication buffer, and only after all local light beams have been processed is the buffer passed on to the neighbors.
This ensures minimal communication overhead.
The main loop of the light beam algorithm is then restarted on all \ac{MPI} \name{ranks} for the communicated light beams.
This is repeated until no more communication is required.
\par
%
Each \ac{MPI} process can additionally use \ac{OpenMP} to allow multiple cores to benefit from shared memory. 
% 
%