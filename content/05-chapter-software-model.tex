\setcounter{chapter}{3}
\chapter{Nerve fiber modelling}
\label{chap:sof:modelling}
% 
% Interesse wecken: warum braucht man es, warum ist es kompliziert, lösbare probleme
\par
In \cref{chap:neuro} the structure of nerve fibers as well as the macroscopic structure of \ac{WM} was described.
The question is, how to represent such a structure in a computer algorithm?
For simple fiber configurations, this can be rather simple.
However it could already been shown, that in \dummy{} \cite{MenzelDissertation} irregular, non symmetrically nerve fiber configurations are essential to acquire a realistic results without diffraction pattern.
This means, that any kind of pattern which can exists, should ideally be representable by an representation.
\par
% 
Many solutions are already available.
One common comes from visualization.
A robe or fiber, \ie{} tube object, is defined by a trajectory with a radius.
From this a surrounding mesh is generated.
In visualization the mesh is used to apply textures. 
However the same meshes are also used in Monte Carlo \ac{dMRI} simulations \cite{Ginsburger2019,ginsburgerDis2019}.
Here the meshes help to calculate, if a water molecule travels through the surface of a nerve fiber, \ie{} the surface of the mesh.
This representation is however very costly, since the number of triangles, which are decoded in the mesh, has to be quite high.
Otherwise the accuracy is lost.
\par
% 
An quite more important task is that the nerve fibers does not overlap each other.
For this purpose either the user has to define such structure in advance, or a computer algorithm has to build such structures from an input.
Thinking of the immense amount of configuration possibilities nerve fiber can have, even in a small volume, the task is for a user except for trivial configurations nearly impossible to solve.
\par
% 
The same is still true for a computer algorithm.
One could \eg{} write an algorithm which define a single fiber in a volume, and then placing the next one but making sure that no one overlaps and so on.
This works up to a certain point fine.
Even if an algorithm finds always a solution to find a path through an already filled volume (which is probably not analytical possible), At some point the volume seems full, but still has a lot of free space in between the fibers.
Of course one can minimise this behavier, \eg{} trying to place almost parallel fibers, however looking again at real tissue data (\cref{fig:brainTPFM} \dummy{}) this is not the case.
Even for a fiber bundle the fibers are packed so densely, that one cannot simple add another fiber in such a way, that over time (\ie{} adding further fibers) volume is wasted.
\par
% 
The solution found during this thesis is , place the nerve fibers in any way the user want to, without the constraint that they are not allowed to overlap each other.
Subsequently, however, the overlap must be removed.
The idea is quite forward.
Check all fibers for collision with each other.
If a collision occurs, try to remove it by moving the coliding parts slidly away from each other.
Repeat this step until all collisions are solved.
\par
% 
This idea \cite{Matuschke2019} with all its necessary requirements is in detail described in the following chapter.
First the representation of a nerve fiber is defined in such a way, that it already takes into account to be as performant as possible for the collision process.
After this building functions, which help the user to define fastly a volume with fibers, are described.
Last the solving algorithm is explained in detail with its parallel running components.
Additionally another approach based on this idea and develop during this thesis with colleges from \ac{dMRI} is explained in detail as well.
It has also a focus on placing nerve cells like astrocytes or olegodendrocytes with their (armen) in the volume.
The cooperation is quite obvious since both simulation techniques investigate the same kind of tissue models.
Since these kind of models are focused on non overlapping tube like structures, they can also applied to other fiber like structures like muscle tissue for example.
\par
% 
All described algorithms here are part of the toolbox \ac{fastPLI} \cite{Matuschke2021}, which is described in detail in \cref{chap:Software}.
% 
\todo{focus von effizienz erwähnen}
\todo{wichtigkeit von irregulariäten}
\todo{kooperationen besser herrausarbeiten}
% 
% 
% 
\section{Nerve fiber representation}
\label{sec:nerve_fiber_representation}
% 
Nerve fibers themself are cabel like structures surrounded by an electric isolating lipid layer of meylin.
The diameter of the axon as well as the myelin thickness can varry from fiber to fiber quite a bit (see \dummy{}).
This means that the representation of nerve fiber models should be capable of representing such variations as well.\\
% 
As described in \cref{sec:fiberArchitecture} \ac{WM} consist out of nerve fibers, which are packed densly together in nerve fiber bundles.
These bundles can merge/split with other bundles and traverse through the brain to connect one region with another region.
The bundles are capable to cross each other, either by crossing of the individual nerve fibers, or fiber bundles bypassing each other in a interwoven kind of structure.
This structures are also a key element to investigate in \ac{3D-PLI}.
Therefore it is especially important that the models are capable of forming such structures without overlap of individual fibers.
\par
% 
An obvious representation is a parametric function that describes a path in 3d space, \ie{} trajectory.
Additionally a forth element could describe the radius of the fiber at the same point:
\begin{align}
f(t) \rightarrow (x(t),y(t), z(t), r(t))
\end{align}
However, this representation does not allow any simple changes afterwards, such as the resolving of collisions.
For this purpose, there must be individual elements on which allow movement or deformation.
The obvious step is to divide the function into discrete sections.
% 
\begin{figure}[!t]
    \setlength{\tikzwidth}{0.85\textwidth}
    \centering
    % \tikzset{external/export next=false}
    \inputtikz{gfx/model/fiber_model}
	\caption[]{Representation of a nerve fiber from a list of spheres.}
	\label{fig:fiberReb}
\end{figure}
% 
Therefore the fiber can be described by a list of 4d points $(x,y,z,r)$, which can be interpret as a chain of cylindrical fiber segments (see \cref{fig:fiberReb}):
\begin{align}
\begin{split}
% \vec{p} &= (x_i,y_i,z_i) \mid x,y,z \in \mathbb{R}\\
% r &\mid r \in \mathbb{R}\\
\mathit{fiber} &= \left\{ \vec{p}_i=(x_i,y_i,z_i), r_i \mid x,y,z \in \mathbb{R}, \, r \in \mathbb{R^+}, \, i \in \{0,1,...,N_{\mathit{points}}-1\}\right\} \\
\mathit{fiber\_segment}_i &= (\vec{p}_i, \vec{p}_{i+1}, r_i, r_{i+1}), \, i \in \{0,1,...,N_{\mathit{points}}-2\}
\end{split}
\end{align}
% 
\begin{figure}[!t]
    \centering
    \setlength{\tikzwidth}{0.75\textwidth}
    \inputtikz{gfx/model/conical_capsule_bb}
    \tikzset{external/export=false}
	\caption[cc and co]{\Acf{CC}: \raisebox{.25em}{\tikz \draw[black](0,0)--(0.275,0);} \ac{CC}, \raisebox{.25em}{\tikz \draw[blue, dash pattern=on 2.5pt off 2.5pt](0,0)--(0.275,0);} capsule, \raisebox{.25em}{\tikz \draw[red, dash pattern={on 2.5pt off 0.9pt on 0.42pt off 0.9pt}](0,0)--(0.275,0);} bounding box \itodo{better in collision solving part}}
	\label{fig:conical_capsule}
\end{figure}
% 
\begin{figure}[!t]
    \centering
    \setlength{\tikzwidth}{0.5\textwidth}
    \inputtikz{gfx/model/capsule}
	\caption{schematic \acreset{CC} \ac{CC}}
	\label{fig:conical}
\end{figure}
% 
Since the fiber radius can change from one point to an adjacent point, the segment can be conical (see \cref{fig:conical_capsule}).
Therefore the fiber segments describes a \ac{CC}.
\par
% 
Additionally later multiple radii could be interpreted as multiple myelin layers.
However at this point it was more feasible to define one radii per point, and to define a "scale" parameter, which divides the radii between 0 to 1 times the radii into N layers.
At the model building and solving process, only the outer layer is important.
\par
% 
This representation has the advantage over a mesh representation of a hull, that it takes much less data to represent it.
This will hopefully increase the computational speed, which will be crucial for a collision solving algorithm.
% 
\section{Sandbox}\label{sec:sandbox}
% 
In computer game terminology, a \textit{sandbox game} is a game that allows the player to build and design anything at no cost.
Analogous to this feature the \pymodule{fastpli.model.sandbox} exists to allow the user to easily and quickly design standard geometric configurations of nerve fibers and bundles.
Since nerve fibers are usually clustered in bundles, construction methods focus on generating nerve fiber bundles from a 2d pattern (seed points) and a nerve fiber bundle trajectory.
In other words, when the finished nerve fiber bundle is cut along its path, the cut plane would show the pattern of the germination points where the cut fibers are located.
% 
\par
% 
This module is split into two consecutive submodules.
The first module handles the seeding process, whereas the second part build from seed points a nerve fiber bundle or volume, filled with individual fibers.
% 
\subsection{Seeding fiber bundles}\label{sec:seeds}
% 
\begin{figure}[!t]
    \def\tikzheight{0.25\textwidth}
    \centering
    \subcaptionbox{\label{fig:triGrid}equilateral triangle grid}[.295\textwidth]{
    \inputtikz{gfx/model/triangular_grid}\hfill}
    \subcaptionbox{\label{fig:rndGrid}random grid}[.295\textwidth]{
    \inputtikz{gfx/model/rnd_circle_points}}\hfill
    \subcaptionbox{\label{fig:crossBundle}populated fiber bundles}[.39\textwidth]{
    \inputtikz{gfx/model/crossing_bundle}}
	\caption{Populating fiber bundles with seed points.}
% 	\label{fig:}
\end{figure}
% 
Seed points are stored as a list of 2d points:
\begin{align}
\mathit{seeds} = \left\{ \vec{p}_i=(x_i,y_i) \mid x,y \in \mathbb{R} , \, i \in \{0,1,...,N_{\mathit{seed\_points}}-1\}\right\}
\end{align}
% 
In order to form particularly dense fiber bundles, a method for generating an equilateral triangular grid was implemented (see \ref{fig:triGrid}).
Mathematically this provides the most densely packed pattern for a 2d circle of same radii packed area.
However, this highly regular symmetrical grid can lead to non realistic results (\eg{} diffraction patterns in maxwell simulation).
It should therefore only be used as an initial configuration.
Since the initial configurations are often unknown, it is probably best to choose a random distribution (see \cref{fig:rndGrid}).
For a circular boundary, this is done using:
\begin{equation}
\begin{split}
\varphi &= \mathrm{uniform}(0,2 \pi) \\
r &= R \sqrt{\mathrm{uniform}(0,1)}
\end{split}
\quad\Rightarrow\quad
\begin{split}
x = r \cos(\varphi)\\
y = r \sin(\varphi)
\end{split}
\end{equation}
% 
As helper functions cutting methods do exists, which will crop the seed points into a rectangular or circular shape.
% 
% 
% 
\subsection{Populating fiber bundles}\label{sec:fillBundle}
% 
\begin{figure}[!t]
    \centering
%     \subcaptionbox{\label{fig:torsionCurve}Torsion along trajectory. The 
% 	\textcolor{green!50!black}{binormal}, \textcolor{red}{principal normal} vector and \textcolor{blue}{tangent vector} vector at each step are also the coordinate system for the seed points.}[.5\textwidth-4.3pt]{
%     \setlength{\tikzwidth}{0.5\textwidth - 4.3pt}
%     \inputtikz{gfx/model/min_torsion}}\hfill
    % 
    % \subcaptionbox{\label{fig:filledBundle}Bending fiber along trajectory $f(t) = \left(\cos(t), \sin(t), 0 \right)$}[.5\textwidth-4.3pt]{
    \resizebox{.75\textwidth}{!}{
    \includegraphics{dev/gfx/circle_bundle.png}}
    % }
	\caption[Bending filled fiber bundle]{Bending fiber along trajectory $\vec{f}(t) = \left(\cos(t), \sin(t), 0 \right)$ \itodo{more interesting example}}
	\label{fig:bendingFiberBundle}
\end{figure}
% 
\begin{figure}[!t]
    \centering
    \setlength{\tikzwidth}{0.75\textwidth}
    \inputtikz[true]{gfx/model/min_torsion}
	\caption[]{Left initial seed point plane. Right plane rotating and placed along the path. At the end, the plane has the same normal vector as the initial plane, however due to the minimal rotation principle, the plane paradoxically is rotated along the normal vector.}
	\label{fig:torsion}
\end{figure}
% 
To populate a fiber bundle, the plane with seed points will be placed at each fiber bundle point $\vec{fb}_i$ along the trajectory.
Essentially this means for each resulting $\mathit{fiber}_j$:
\begin{align}
    \mathit{fiber}_j = \left\{ \mat{R} \cdot (x_j, y_j, 0) + \vec{fb}_i \, | \, i \in \{0,1,...,N_{\mathit{seed\_points}}-1\}\right\}
\end{align}
The question however is, which rotation matrix has to be applied.
Since the trajectory is only a 2d object, \ie{} a line, no ... are perpendicular to its tangential vector.
In mathematics the torsion of a curve can defined with a principal normal vector and a binormal vector.
This however has the problem, that the line has a torsion for a helical function, \ie{} the line \say{rotates} along its path.
This would mean, that if the seed point plane would be places according to the principal and binormal vector, that also the individual fibers would rotate around the fiber bundle trajectory.
This is in principle possible, however practical not existent in real tissue.
\\
A more sensible solution would be to apply a rotation in such a way, that the rotation along the fiber bundle trajectory is minimal.
This can be achieved by calculating the rotation matrix, which would rotate the current tangential vector $\vec{t}(i)$ to the one of the next point $\vec{t}(i+1)$.
The rotation matrix $\mat{R}(\vec{a}, \vec{b}$ between two vectors $\vec{a}$ and $\vec{b}$, if $\vec{a} \nparallel \vec{b}$ can be calculated via
\begin{align}
\begin{split}
    \vec{a} =& \vec{a} / |\vec{a}|\\
    \vec{b} =& \vec{b} / |\vec{b}|\\
    \vec{v} =& \vec{a} \times \vec{b}\\
    c =& \vec{a} \cdot \vec{b}
\end{split}
\quad
\begin{split}
    \mat{U} =& \begin{pmatrix} 0 & \vec{v}_z & -\vec{v}_y\\ -\vec{v}_z & 0 & \vec{v}_x\\ \vec{v}_y & -\vec{v}_x & 0\end{pmatrix}\\
    \mat{R} =& \mathbb{1} + \mat{U} + (\mat{U} \cdot \mat{U}) \cdot (1 - c) / |\vec{v}|^2
\end{split}
\end{align}
The parallel case is trivial.
\\
This tool allows the following procedure:
First place the seed point plane at the first fiber bundle point $\vec{fb}_0$ and rotate it with $\mat{R}(\hat{\vec{e}}_z, \vec{t}_0)$.
Then for each step, rotate the plane at it original origin according to $\mat{R}(\vec{t}_i, \vec{t}_{i+1})$ and place it at $\vec{fb}_{i+1}$.
To smooth the transition, the tangential vector at step $i$ is calculated by
\begin{align}
    \vec{t} = \frac{1}{2} \frac{\vec{fb}_{i-1} + \vec{fb}_{i+1}}{|\vec{fb}_{i-1} + \vec{fb}_{i+1}|}
\end{align}
% 
Finally all points according to one fiber can be stored inside the fiber bundle object.
An example is shown in \cref{fig:bendingFiberBundle}
% 
% 
% 
\subsection{cube models} \label{sec:cubeModelBuilding}
% 
\begin{figure}[!t]
    \centering
    \setlength{\tikzwidth}{0.5\textwidth}
    \inputtikz{gfx/model/cube_build}
	\caption{Populating a cuboid with straight fibers initialized by seed points along the direction $\vec{v}$.}
    \label{fig:cubeBuild}%
\end{figure}
% 
As later will be shown, cubical models are quite interesting to investigate due to the fact, that a pixel in the \ac{3D-PLI} setup is a cube with the height of the tissue thickness.
Therefore a method exists, which fills such a volume with a fiber population of orientation $\vec{v}$ (see \cref{fig:cubeBuild}).
The individual fibers are as usually initialized with a seed point plain.
This plane is virtually placed before the cubic volumen end behind it in the direction of the orientation such that the origins of the seed point planes line up with the origin of the cube.
Next the seed points are virtually connected.
If a line hits the volume, the entry and exit point is calculated and saved as a fiber of the fiber bundle.
% 
% 
% 
\subsection{cylindric models}
% 
\begin{figure}[!t]
    \centering
    \setlength{\tikzwidth}{0.31\textwidth}
    \subcaptionbox{\label{fig:cylCircular}%
        Circular population.
    }[.33\textwidth-1ex]{
    \inputtikz{gfx/model/cylinder_circular}}\hfill
    % 
    \subcaptionbox{\label{fig:cylRadial}%
        Radial population.
    }[.33\textwidth-1ex]{
    \inputtikz{gfx/model/cylinder_radial}}\hfill
    % 
    \subcaptionbox{\label{fig:cylParallel}%
        Parallel population.
    }[.33\textwidth-1ex]{
    \inputtikz{gfx/model/cylinder_parallel}}
	\caption{Populating of cylindrical objects. The green area shows the area corresponding to the seed points xy-plane. The coordinate system \textcolor{RED}{red} indicates the coordinate origin for the seed points.}
% 	\label{fig:}
\end{figure}
% 
The last method allows, among other things, to create arcs of circles of fibers.
It uses a cylindrical volume as template.
% 
Since a cylinder has three \say{coordinates}, a radial, a angular and the length, all three were implemented to provide an option to populate the volume.
\\
% 
First the coordinate system has to be defined.
The cylinder of an outer radius $r_{\mathit{out}}$ and an inner radius $r_{\mathit{in}}$ is oriented along the z-axis with a height $h$, starting at $(0,0,0)$.
Additionally, the cylinder can be cut radially from a directional angle $\alpha$ to $\beta$, to only fill a part of it.
\\
% 
For all methods applied, if the seed point plane leaves the cross section plane to be filled, the seed points lying outside are ignored.
% 
\paragraph{a) circular} mimics a radial path of the cylinder (see \cref{fig:cylCircular}).
The seed points are placed along the surface of the cross section of the first $\alpha$ direction angle.
The origin of the seed point plane is placed on the origin of the cylinder.
From there, the fiber runs in a circular pattern to the second directional angle $\beta$.
The step size of the circular path can be changed.
% 
\paragraph{b) radial} The fibers will be placed fromm the iner wall to the outer wall of the cylinder.
The seed point plane is therefore placed at the inner wall, with the origin at the lower corner of the first angle $\alpha$ (see \cref{fig:cylRadial}).
The fibers are then generated radial until they hit the outer wall of the cylinder.
Thus, the fiber density decreases along its path.
% 
\paragraph{c) parallel} fibers are oriented along the cylinder (see \cref{fig:cylParallel}).
Here the seed points are located in bottom plane, with the both origins at the same point (see \cref{fig:cylParallel}). The orientation of the plane is with the x-axis at $\SI{0}{\degree}$
% 
% 
% 
\section{Solving fiber collisions}
\label{sec:Solver}
% 
% 
The focus of this method is to allow the user to define any given fiber path way the way he/she wants it.
This allows the most freedom on initialization.
Of course in most cases, fiber since they are 3d volumetric objects, will overlapp with each other.
It is the goal of the following algorithm, to find such collisions and solve them by moving the involved fiber segment in such a way, that a collision free volume will be generated by minimal movement.
% 
This allows the user to specify complex interwoven structures like nerve fiber crossing in a quite simplistic way.
% 
The algorithm also allows the user to specify certain boundr condition, \eg{} the mean value of the fiber segments, since during the solving process the shape can depending on the intial condition change quite a bit.
\\
An important feature is the visualization of the solving process.
This allows the user to see what happens and therefore intervene if necesarry as as early as possible.
This is very important since the solving process, depending on the volume slice and number of objects, can take a lot of time.
\par
% 
The following parts of this chapter describe the main algorithm, \ie{} the collision detection process and the movement phase, as well as the visualization.
% 
\par
\noindent\rule{\textwidth}{2pt}
\par
% 
%
\subsection{solver-main}
% 
\begin{lstfloat}[!tb]
\lstset{style=python}
\begin{lstlisting}[]
def step():
    # Reset Parameter
    SetSpeed(objects, 0)
    
    # Building Octree
    octree = Octree(objects)
    
    # Collision Detection
    for leaf in octree:
        colliding_objs = CheckLeaf(leaf.fiber_list)
        colliding_list.insert(colliding_objs)
	
    # Seperation Process
    MoveObject(colliding_list)
	
    # Shape Control
    SegmentLength(colliding_list, target_length)
    BendingRadius(colliding_list, target_curvature)

    return colliding_list.is_empty()
\end{lstlisting}
\caption{Pseudocode of the \code{main} algorithm: The function \code{FiberCollisionSolver} will loop the followings four steps, which are run in parallel, until no collision are detected anymore: 1. build an \code{octree} from all objects, 2. \code{Collision Detection}, 3. \code{Seperation Process} and 4. \code{Shape Control}. \itodo{check algorithm, spetially movement phase}}
\label{alg:pseudocode_solver}
\end{lstfloat}
% 
Apart from the initialization of parameters the main function of the solver algorithm is one \code{step} of the solving process.
The algorithm is with reasons not a loop for its self, so that the user can interact at each step with the data or parameters if necessary.
This \code{step} function (see \cref{alg:pseudocode_solver}) can be split into the following consecutive parts:
ordering the objects into an octree, checking each branch of the octree for colliding objects, seperating the colliding objects and controlling the shape of the fibers.
The return value of the function is the check, if no colliding objects were founds.
%
A stand alone algorithm is publish in \cite{Matuschke2019}.
At this point it is integrated inside the \ac{fastPLI} package under \pymodule{fastpli.model.solver.Solver}.
Before going into the details of the algorithm, the collision detection algorithm is described.
% 
% 
% 
\subsection{Collision Detection}
\label{sec:collisionDetection}
% 
\begin{lstfloat}[!t]
\resizebox{\textwidth}{!}{
% \begin{sideways}
\begin{tabular}{|cc|cc|}
\hline
\hspace{1em} &
\begin{minipage}{0.4625\textwidth}
\lstinputlisting[style=cpp,basicstyle=\scriptsize\ttfamily,firstline=1,lastline=32]{code/collision_detection.py}
\end{minipage} & \hspace{1em} &
\begin{minipage}{0.4625\textwidth}
\lstinputlisting[style=cpp,basicstyle=\scriptsize\ttfamily,firstline=33,lastline=64,firstnumber=35]{code/collision_detection.py}
\end{minipage} \\
\hline
\end{tabular}
% \end{sideways}
}
\caption{Collision detection between two capsule objects. The distance as well as the points on the line segments is returned. A collision takes place if the distance is smaller than $\mathit{cone_a.r}+\mathit{cone_b.r} > d$.}
\label{alg:pseudocodeCollisionDetection}
\end{lstfloat}
% 
As described in \cref{sec:nerve_fiber_representation}, nerve fibers are represented as a chain of spheres, where two adjacent spheres are combined to form a fiber segment that has a \ac{CC} (see \cref{fig:conical_capsule}).
% 
Therefore an algorithm is necessary to calculate a collision between up to \ac{CC}.
This is a non-trivial task and very computationally intensive.
Therefore it was decided to change the object representation for the collision detection part from a \ac{CC} to a capsule (see \cref{fig:conical_capsule}).
This means that the radii of the \ac{CC} for both spheres grow to the maximum of the two spheres $r_{\mathit{capsule}} = \mathrm{max}(r_0, r_1)$.
This has the disadvantage that at intersections of two adjacent cones the radii can actually be smaller, but if the change in radius is not rapid, this is acceptable.
\\
The algorithm for detecting collisions between two capsules is shown in \cref{alg:pseudocodeCollisionDetection}\footnote{\href{https://www.john.geek.nz/2009/03/code-shortest-distance-between-any-two-line-segments/}{https://www.john.geek.nz/2009/03/code-shortest-distance-between-any-two-line-segments/}}.
% 
It works on the principle that it calculates the shortest distance between two line segments.
Three cases can occur.
First, the shortest distance is a line perpendicular to two of the two line segments of the cones.
Second, only one line segment is perpendicular to the line of the shortest distance.
The other has an anchor point at either its first or second point.
Third, the shortest distance is a connection between one of the points of the two cones.
For cones, a collision occurs when the distance is smaller than the sum of the two radii.
\\
\begin{figure}[!t]
    \centering
    \def\tikzheight{0.5\textwidth}
    \inputtikz{gfx/model/shortest_dist}
	\caption{shortest distance}
	\label{fig:shortDist}
\end{figure}
% 
The problem with \ac{CC} is that as the radii along its axis change, it is no longer simply the case that the shortest distance between two line segments is also the shortest distance between a 3d \ac{CC}.
To do this, the lines on both object surfaces containing the closed point must be found.
However, this is very complex to calculate and was therefore rejected.
% 
It is expected that the calculation of the collision check will be the most costly function at this point.
Therefore the next logical step is to reduce the scope of the calculations as much as possible.
A first brute force collision check would check each object with all other objects.
The next object must then be checked with $n-1$ etc.
This results in a calculation effort of $\mathcal{O}(n^{2})$, which is not acceptable for large n.
To reduce the number of collision checks to be performed, an octree structure is used.
% 
\subsection{Octree}
% 
\begin{figure}[!t]
    \centering
    \subcaptionbox{\label{fig:octreeCube}octree}[.3\textwidth]{
    \def\tikzheight{0.6\textwidth}
    \inputtikz{gfx/model/oct_tree}}
    \subcaptionbox{\label{fig:collision2D}collision 2d}[.65\textwidth]{
    \def\tikzheight{0.6\textwidth}
    \inputtikz{gfx/model/collision_tree}}
	\caption{}
	\label{fig:octree}
\end{figure}
% 
A \name{tree} is a data structure that consists of a collection of \name{nodes} that are connected to each other.
A node is connected in the direction of the \name{root} with a single parent node and in the direction of the \name{branches} with several \name{children} or \name{branches}.
The nodes at the end of a branch are called \name{leaves}, which contain the data.
Traversing an evenly distributed tree has the advantage that the cost of the traversing it is $\mathcal{O}(\log(n))$.
\\
% 
An octree is a special kind of tree where each node contains eight children.
This allows to divide a cubic volume into eight equally cut sub-cubes.
An example is shown in \cref{fig:octreeCube}.
This means that the length of the volumes shrinks exponentially with $(1/2)^\mathit{level}$.
An octree can be implemented in different ways.
Here a recursion function was chosen (see \cref{alg:pseudocode_octree}).
% 
\begin{lstfloat}[!tb]
\lstset{style=python}
\begin{lstlisting}[]
def octree(volume, objects):
    if num(objects) > threshold:
        sub_volumes, sub_objects = split(volume, objects)
        leafs = [octree(v,o) for v,o in zip(sub_volumes, sub_objets)]
    else:
        leafs=[objects]
    return leafs
\end{lstlisting}
\caption{Pseudocode of octree}
\label{alg:pseudocode_octree}
\end{lstfloat}
% 
In computer science, a recursive function means that a function (can) call itself.
The idea is the following.
At the beginning all objects must be sorted into the eight leaves of the current node (if the number of objects is not trivial to small).
This means that for each object it must be checked whether there is a collision with one or more of the eight leaves.
However, since this already means a high test effort, the test function should be as fast as possible, usually approximate.
For this purpose only the \ac{AABB} of the object is checked if it collides with the sheet volume (which is its own \ac{AABB}) (see \cref{fig:collision2D}).
A collision detection of two \ac{AABB}s is rather simple (see \cref{alg:collisionAABB}).
% 
\begin{lstfloat}[!tb]
\lstset{style=python}
\begin{lstlisting}[]
def aabb_collide(aabb_0, aabb_1):
  for i in dim(aabb):
      if aabb_0[i].min > aabb_1[i].max:
         return false
      if aabb_0[i].max < aabb_1[i].min:
         return false
  return true
\end{lstlisting}
\caption{Pseudocode collision between aabbs.}
\label{alg:collisionAABB}
\end{lstfloat}
% 
When all objects are sorted into their respective sub-volumes, recursion can begin.
Since a branch can be considered a node, the same algorithm can be executed again until a desired limit or property is reached.
This means that the current (sub-)volume will be split into eight sub-volumes again, if necessary, and the objects of the current (sub-)volume will be sorted into the new sub-volumes.
The recursion also means that the next function call must contain a list of the current objects.
This means either that the objects must be copied, which is time-consuming, or they must be moved, which is also time-consuming depending on the structure, and they must be moved back, or a pointer or index must be traversed.
The last option was chosen because it proved to be the fastest in a speed test during the implementation process.
The next question is, which is the desired goal to stop the branching process and characterize the node as a leaf.
\par
% 
The goal is of course the reduction of the computing time.
However, this means that there is no simple answer for complex models and thus for unique octrees.
The usual way is to have the three following restrictions.
% 
\paragraph{Number of level limitation:}
The maximum number of steps is usually limited in the following two ways.
First, when a threshold value for the counter of the maximum number of levels is reached.
Since the since of the volume shrinks exponential, this is a good way to control the amount of calculations.
Usually, however, this is further limited by limiting the minimum size of the volume.
For a number of object sizes, this means that splitting into the next volume only makes sense if the object sizes are at least twice smaller than the current volume.
Otherwise, all eight volumes would contain all objects and the number of collision checks would increase by eight.
Since all objects are expected to be in the same order of magnitude, a global value can be set by first measuring the maximum \ac{AABB} and setting the threshold twice higher.
This automatically limits the maximum number of levels that can be reached.
% 
\paragraph{Minimal number of objects:}
The optimal minimum number of objects in a node to start the final collision algorithm must be measured, since it depends on the instructions actually executed on the system.
It is a trade-off between executing less computationally intensive, costly and highly accurate collision checks and executing at least eight more branches.
In the development phase of the algorithm this value was chosen as \dummy{20}.
Of course the user can change this hard coded value if necessary. 
\\
% 
With the resulting list of colliding object pairs, the next task is to perform the separation process.
%
\subsection{Separation Phase}
To solve a collision between two \ac{CC} objects, each point $\vec{p}_i$ and $\vec{p}_{i+1}$ of both objects must be moved.
The movement is parallel to the smallest distance line between the two objects.
To take the 3D placement into account, the movement is weighted by the distance of each point from the intersection with the smallest distance line (see \cref{fig:shortDist}):
\begin{align}
v_i = \dummy{}
\end{align}
This leads to a more controlled movement if \eg{} only the two ends of the fiber objects collide.
\\
% 
TThe motion is stored as the sum of all collisions for each object in a velocity \code{std::vector}.
The maximum speed is limited to a value of $v_{\max} = 0.1 \times \min(\mathit{object radius})$.
This is limited due to two required properties. First, it prevents movement through another object and second, it smoothes the movement and thus the maximum achievable density of the resulting models.
However, this also means that the solution process takes more time.
\\
% 
A special case are the end points.
These are only allowed to move along the surface perpendicular to the first / last segment line.
This prevents the fibers from growing into infinity.
% 
\section{Shape Control}\label{chap5:ShapeControl}
The movement of individual points can lead to a distorted fiber model, \eg{} two points move very far apart.
Therefore boundary conditions must be specified.
It was decided to use the following two conditions.
% 
\subsubsection{Mean segment length}
% 
\begin{figure}[!t]
    \centering
    \setlength{\tikzwidth}{.45\textwidth}
    \subcaptionbox{merge}[.49\textwidth]{
    \inputtikz{gfx/model/model_merge}}
    \subcaptionbox{split}[.49\textwidth]{
    \inputtikz{gfx/model/model_split}}
	\caption{Length control for fibers $f$ and $f'$}
	\label{fig:mergeSplit}
\end{figure}
% 
% 
\begin{figure}[!t]
    \centering
    \setlength{\tikzwidth}{0.75\textwidth}
    \tikzset{external/export next=false}
    \inputtikz{gfx/model/model_length}
	\caption{different fiber segment length.}
	\label{fig:modelLength}
\end{figure}
% 
The mean segment length is the distance between the two points of an object.
If the segment length becomes too small/large, the points within a fiber corresponding to the object are merged/separated, adding one point less/one new point.
The minimum/maximum distance of the object is set to $d_{\min} = \frac{2}{3} \overline{d}, d_{\max} = \frac{4}{3}\overline{d}$.
Therefore the mean value of the object is:
\begin{align}
\frac{d_{\min} + d_{\max}}{2} = \overline{d}
\end{align}
% 
If a new point is created due to exceeding the maximum limitation, the new points $\vec{p}_{new}$ radius $r_{new}$ and velocity $\vec{v}_{new}$ are 
\begin{align}
\vec{p}_{new} = \frac{\vec{p}_{i} + \vec{p}_{i+1}}{2},\enspace
r_{new} = \frac{r_{i} + r_{i+1}}{2},\enspace
\vec{v}_{new} = \frac{\vec{v}_{i} + \vec{v}_{i+1}}{2}
\end{align}
% 
\subsubsection{Bending radius}
% 
\begin{figure}[!t]
    \centering
    \def\tikzheight{.40\textwidth}
    \subcaptionbox{Boundry segment length: lower bound $phi=\SI{60}{\degree} \xrightarrow{} r_{min} \geq \SI{0.5773}{} \cdot l_{mean}$}[.475\textwidth]{
    \inputtikz{gfx/model/model_circle}}\hfill
    \subcaptionbox{\label{fig:boundaryLength}Boundary segment radii: lower bound $r_{min} \geq \fiberRadiusMean $}[.45\textwidth]{
    \inputtikz{gfx/model/model_circular}}
	\caption{Geometrical boundry condition for fiber segment length \segLength and fiber bending radius \segRadius.}
	\label{fig:modelCircle}
\end{figure}
% 
The bending radius is defined as the circle radius corresponding to the circle defined by three adjacent points $\vec{p}_{i-1}, \vec{p}_{i}, \vec{p}_{i+1}$ (see \cref{fig:boundaryLength}). 
The limit is set as a minimum radius of $r_{\min}$.
If a $p_{i}$ point in a fiber falls below this value, the three points are moved.
$p_{i-1},p_{i+1}$ is moved \dummy{} and $p_{i}$ opposite each other.
This reduces the curvature.
\\
% 
\subsection{Movement Phase}
All movements are added to the velocity vector before performing the overall movement.
The algorithm performs each step sequentially (see \cref{alg:pseudocode_solver}).
% 
Finally a volume is marked as collision free, if no collision are found and all boundary conditions are fulfilled. 
The boundary conditions can be set to 0 to ignore them.
Additionally a drag value can be set, to reduce the velocity by its factor after each step.
It can help to reach a collision free volume faster, however the density will be significantly reduced.
Therefore the value is to 0 so that after each step the velocity is reset to $\vec{0}$. 
% 
\subsection{Optimization / Parallelisation}\label{sec:modelOpt}
% 
Among other techniques, two main optimisation techniques are used to speed up the process.
% 
\paragraph{Memory alignment}
The \code{std::vector} has the advantage that the data is linear in memory.
Modern \acp{CPU} have a built-in method called \say{ache prefetching}.
Data must be prepared and sent from the \ac{RAM} to the cache of the \acp{CPU}.
This takes time.
The main advantage of the cache is that it is very fast.
However, since it must be very close to the \ac{CPU}, the cache is very fast. (in modern systems the speed is already limited by the speed of light) its size is very limited (usually around $\si{\mega\byte}$).
The prefetcher is an ingenious directive, which not only obtains the item at address $i$ in memory, but also the item next to it ($i+1$ or $i-1$ depending on the algorithm).
Since many algorithms pass through arrays, the next item to be calculated is usually the next (or previous) item.
Therefore the time needed to copy the data into the cache and prepare it is reduced.
It can be shown that for linear operations on the memory the cache prefetcher reduces the time so much that it behaves as if the \ac{CPU} has an infinite cache.
% 
\paragraph{OpenMP}
% 
To be able to use several \acp{CPU}, \openmp is used. With a structure like an octree, the separation process into the new partial volumes can already be parallelized up to eight cores.
However, since all eight cores have to share the object list data, even if they are only reading, it is no longer possible from this point on to achieve up to eight times the speed (see later acceleration measurements \dummy{}).
\\
% 
Furthermore, all instructions containing loops, such as the separation phase, are also parallelized with \openmp.
% 
% 
% 
\section{Visualization}\label{sec:visualization}
% 
A visualization tool was written to visualize the fiber configuration.
This enables the user to get a direct feedback (\eg{} after each step) to adjust the initial fiber configuration or boundary condition.
It is written in \cpp{} and \opengl{} \cite{isocpp, khronos}.
\\
% 
\ac{CC} are rendered using the \code{gluCylinder} function provided by the \name{GLUT} library for a rough but fast visualization.
Representation and thus the collision check algorithm is also provided by the \name{GLUT} library for a rough but fast visualization.
For a more accurate and correct visualization of the \ac{CC} a self-implemented rendering was developed.
The first step in the visualization of surfaces is usually the generation of a \name{mesh} from triangles.
A texture can then be placed on each triangle.
Since fibers have to be visualized here, the mesh is generated as a tube surrounding the fiber with circularly arranged points around a fiber point $p_i$ (see \cref{fig:mesh}).
Corner points and normals are calculated from the mesh, which are finally rendered with a color within an illuminated scene.
To enable visualization of the inner axon, the myelin sheath can also be rendered.

% 
\begin{figure}[!t]
    \setlength{\tikzwidth}{0.5\textwidth}
    \subcaptionbox{\label{fig:mesh}mesh \dummy[triangles are missing]{}}[0.49\textwidth]{
    \inputtikz{gfx/model/vis_a}}
    \subcaptionbox{vis}[0.49\textwidth]{
    \inputtikz{gfx/model/vis_b}
    }
	\caption{Generating mesh for visualization.}
	\label{fig:vis_mesh}
\end{figure}
% 
\paragraph{Disclamer}
This is a fast implementation.
Current rendering software uses much more advanced techniques.
However, this rendering algorithm has been written to be an easily integrated tool that uses only the additional \name{OpenGl 2} and \name{GLUT} library.
\\
% 
A more advanced tool, the \name{FAConstructor} \cite{Reuter2019} was written by Andr'e Reuter as part of this doctoral thesis.
This tool uses \name{OpenGl 3} and additional calculation on the GPU. Additionally it allows a user-defined interactive technique to create a 3D fiber model.
The next step is already carried out with the visualization tool by Nicole Schubert called \name{PLIVis}.
% 
\subsection{Wall opacity}
% 
In order to visualize axons within the myelinated nerve fibers, the visualized vertices must be transparent.
However, this requires sorted vertices along the z-axis (viewer/camera? axis).
This is needed because vertices are rendered from back to front, so that the absorption of light can be taken into account.
This process takes a certain amount of time and is therefore only recommended for screen shoots at this time (see \dummy{}).
% 
% 
\vspace{5pt}
\hrule
\vspace{6pt}
% 
\newpage
% 
\section{Medusa - sphered nerve and cell modelling}
% 
\itodo{Section neu schreiben. Bisher nur Ideen.}
% 
Additionally to the previous discussed modelling algorithm (see \cref{sec:Solver}), the \ac{MEDUSA} algorithm, was developed in a cooperation with the team Neurospin from \ac{CEA} in France \cite{Ginsburger2019}. The targed was to develop an algorithm which can build a library of \ac{WM} tissue. This library should not only contain nerve fibers, but also other cell types like olegodendrocites or astrocytes. These cell types are currently not used in \ac{3D-PLI} routine analysis however in \ac{dMRI} the cell are quite important [\dummy{}]. Furthermore these cells take up additional volume which results in different nerve fiber configurations.\\
% 
Since this tool aims to build a statistically library, other parameters are chosen for boundary conditions. These parameters are chosen as close as possible from the current \ac{dMRI} models:
\dummy{}\\
\dummy{}\\
% 
% Instead of choosing \ac{CC} the fibers and cells are represented as a collection of spheres. This has the advantage that the collision of spheres are more easier to be calculated:
% \begin{align}
%     d < r_i + r_j
% \end{align}
% 
On the other side more spheres are needed to represent a fiber. There can always be a resulting overlapp which depnding on the usecase, can lead to .. results.\\
% 
Cells are also represented as a collection of spheres, filling out the sum of the spheres volume. \\
%
In this theses cells are disregarded. A full description of the construction with astrocytes and olegodendrocytes can be found in \cite{Ginsburger2019}.
% 
\subsection{Algorithm}
% 
\begin{figure}[!t]
\centering
% \resizebox{0.75\textwidth}{!}{
\setlength{\tikzwidth}{0.75\textwidth}
\inputtikz{gfx/model/medusa/medusa_spheres}
% }
\caption{modified from \cite{Ginsburger2019}}
\label{fig:model:medusa_4}
\end{figure}
%
% \begin{figure}[!t]
%     \centering
%     % \resizebox{0.75\textwidth}{!}{
%     \setlength{\tikzwidth}{0.75\textwidth}
%     \includegraphics{gfx/model/medusa/4.jpg}
%     % }
% 	\caption{4 \cite{Ginsburger2019}}
% 	\label{fig:model:medusa_4_org}
% \end{figure}
% 
Since all objects are represented as a collection of spheres (see \cref{fig:model:medusa_4})
\begin{align}
    \mathcal{S} = \{ (x_i,y_i,z_i,r_i) : i \in \{0, 1, ..., n_\text{objects}-1\}  \} 
\end{align}
% 
, a collision is present if (VCS !!!)
% 
\begin{align}
\begin{split}
d<r_i+r_j\\
d = \abs{\vec{p}_i - \vec{p}_j}
\end{split}
\end{align}
% 
However since neighboring spheres in one fiber are colliding for a densly populated fiber, they have to be excluded if
\begin{align}
\begin{split}
d(i,j) &\leq  r_i + r_j\\
d(i,j) &= 
\begin{cases}
\sum_{n=i}^{j-1} \abs{\vec{p}_n - \vec{p}_{n+1}},& \text{if } j-i \geq 1\\
0 & \text{otherwise}
\end{cases}
\end{split}
\end{align}
% 
Spheres inside cell bodys are not checked for collision, since their volume aproximate? the volume of the cell.\\
% 
The calculation of collisions is done via the GPU architecture. For this a first implementation was written with the \name{AxisAligedSortedSearch} \cite{Karras2012}. It sorteds the spheres along one axis, \eg{} x-axis, x-axis, and search for each sphere the fist and last possible collision on this axis:
\begin{align}
\begin{split}
\mathcal{C}_i = \{ s \in \mathcal{S} \mid \abs{s_i.x - s_j.x} < r_i+r_j \}
\end{split}
\end{align}
% 
\begin{lstfloat}[!t]
	\lstinputlisting[style=cpp]{code/medusa.cu}
	\caption{Pseudocode of \acs{MEDUSA} collision checking.}
	\label{alg:medusa_collision}
\end{lstfloat}
% 
The above described algorithm is currently used for volumes $\approx \SI{200}{\micro\meter}$. For this volume size the algorithm is for the current use fast enough. However, more advaned algorithm exist wich can be applied here (\eg{} \name{BoundindBoxHierarchy} \cite{Karras2012}).
% 
\begin{figure}[!t]
    \centering
    \resizebox{0.95\textwidth}{!}{
    \includegraphics{gfx/model/medusa/8.jpg}}
	\caption{8 \cite{Ginsburger2019}}
	\label{fig:medusa_8}
\end{figure}
% 
\begin{figure}[!t]
    \centering
    \resizebox{0.95\textwidth}{!}{
    \includegraphics{gfx/model/medusa/11_.jpg}}
	\caption{11 \cite{Ginsburger2019}}
	\label{fig:medusa_11}
\end{figure}
% 
% 
% 
% 
% 
% 
% 
%
% Neurospin works with \ac{dMRI} signals.
% One focus is on the analysis of the fiber architect of the human brain.
% \ac{dMRI} is here quite handy since it is currently the only technique to allow in-vivo measurements to analyse the orientation of white matter tracts. Another importance is the availability of \ac{MRI} machines in almost every hospital in the western civilization.
% Although their resolution is with \SIrange{1.5}{3}{\tesla} limited.
% However, Neurospin is equipped with a mordern \SI{7}{\tesla} \ac{MRI}.
% This makes it possible, including higher measurments times on post mortem brain tissue, a \ac{dMRI} resolution up to \SI{200}{\micro\meter}.
% This makes it possible to allow \ac{3D-PLI} to verify and enhance the analysis of current developed tractography data. 
% %
% Along this works they developed a simulation tool (name) which is computing a Monte-Carlo simulation on the diffusion process in virtual tissues.
% Therefore, for simulations of the \ac{dMRI} signal in the brain, geometric models of nerve fibers as well as nerve cells are required.
% %
% The common goal was, due to a work packes inside the \ac{HBP}, the development of a common general purpose tool to build a geometrical library of nerve fiber configurations.
% Therefore it was decided to work based on the first approaches \cite{Ginsburger2018}.
% %
% \begin{quotation}
% We design a novel white matter numerical phantom generation algorithm which constructs biomimicking geometric configurations with few design parameters, and enables to control the level of disorder of the generated phantoms. The influence of various geometrical parameters present in white matter, such as global angular dispersion, tortuosity, presence of Ranvier nodes, beading, ...
% \end{quotation}
% %
% It is therefore qualified to generate a large database or library of parameter controlled white matter volumes.
% %
% \paragraph{differences:} 
% \begin{itemize}
%     \item All objects are aproximated with spheres.
%     \item Statistical ... of tissue
%     \item diffusion specific parameters
%     \item pathological changes like axon beeding
% \end{itemize}
% 
\section{"Conclusion"}
This allows a user to specify any initial configuration and reaching a collision free model, which, depending on the initial overlap, follows the initial geometry.
The disadvantage obvious is that the configuration has to change.
However since biological tissue is deformable and not "caotic" itself, it follows its natrual behavier.
