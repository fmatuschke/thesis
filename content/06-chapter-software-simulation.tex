\chapter{Simulation}
\label{cha:simulation}
% \minitoc
% 
\comment{\paragraph{Ziele:} 
\begin{itemize}
    \item Aufbau simPLI Pipeline
    \item Umsetzungen der einzelnen Elemente
    \item Test einzelner Elemente
    \item Parallelisierungen/Optimierungen
\end{itemize}}
%
The \ac{3D-PLI} simulation is based on he previous developt tool \textit{simPLI} \cite{Dohmen2015}, which uses linear optics \cite{} to simulate the light tissue inteaction in the \ac{PLI} setup. This version however uses M\"uller matrices \cite{} to define the optical elements and the Stokes vector \cite{} for describing the light \cref{sec:Mueller-Stokes}.\\
% 
The simulation is split into two conscutive parts.
The first part is to build a discrete grid model from a given fiber configuration (\eg \dummy).
The second part uses the discrete volume to calculate the resulting \acs{PLI} images.
%
%
%
\section{DV-Generator}
\label{sec:dv_generator}
% 
To calculate a discrete volume of optical properties from a fiber configuration, the same fiber representation as in \cref{chap:modelling} is used.
Therefore the problem of discretisation can be reduced to the case of a single \ac{CC} object $(\vv{p_i}, \vv{p_{j}}, r_i, r_{j})$.
% 
Since the birefringend orientation inside a fiber can be represented either with the micro or marcoscopic model (see \dummy), the radial or parallel orientation for a point $q$ to the object has to be calculated.
In the case of parallel orientation the orientation $o$ is:
\begin{align}
\begin{split}
    o = \frac{\vv{p}_i - \vv{p}_{i+1}}{\abs{\vv{p}_i - \vv{p}_{i+1}}}
\end{split}
\end{align}
% 
For the radial case the smallest distance to the line segment $(\vv{p}_i,\vv{p}_{i+1})$ has to be calculated:
(see collision detection?)
% 
\begin{figure}[!tb]
\centering
\resizebox{0.75\textwidth}{!}{
\inputtikz{gfx/simpli/vector_model.tikz}
}
\caption{discretisation of fiber}
\label{fig:fiber_discretisation}
\end{figure}
% 
The radial orientation vector is then parallel to the smallest distance vector $\vv{d}$.
The distance is also used to check wich layer of the fiber is "active" (\eg axon or myelin). 
% 
The \ac{CC} object has the following \ac{AABB}:
\begin{align}
\begin{split}
    \sum_{1,2,3} \epsilon_{i,j} \times \hat{e}_i \times \max(p_{0,j}, p_{1,j}) + \max(r_0, r_1)
\end{split}
\end{align}
To calculate the discreticed voxels, this \ac{AABB} is iterated. for v in V(AABB): \dummy
% 
Iterating over all voxels and afterwords over all objects of all fibers yield in the discretisec volume model.\\
% 
To account for the race condition, when two objects take up the same voxel (\eg neighboring fiber segments) a distance map \textit{distance array} is used.
In this 3d array the distance $d$ for a calculated orientation will be saved.
If a new point for another object has a smaller distance, it overwrites the orientation and distance.
Furthermore a 3d "label" array is needed, which represents the id of the physical properties which have to be used (\eg which layer or which fiber properties).
The value inside the label array corresponds to a look up table of a \textit{property list}.
% 
The DV-Generator returns the \textit{label field}, \textit{vector field} and \textit{property list}.
% 
\footnote{same calculations for cells, except that the birefingence and orientation is 0.}
% 
\section{Algorithm}
% 
\subsection{parameter list}
% 
voxel\_size, VOI, fiber\_bundles, \dummy
% 
\subsection{parallelisation}
% 
Two methods are used to parallise the algorithm on the \ac{CPU}.
The first uses \openmp for the parallelisation of filling the \ac{AABB} volume of each object.
The second uses \mpi to allow the distribution on multiple \ac{CPU} cores without the capability of shared memory. 
% 
The parallelisation of the \ac{AABB} volume leads to a race condition if multiple threads want to write in the same memory address (or coordinate) (\eg two objects occupy the same space).
A solution with a lock would be very slow.
Since the loop is over all $(i,j,k)$ indices of the three space dimensions, the parallelisation can be done over the indices.
However this leads to a slow implementation, since for every object new threads have to be spawned.
Therefore the parallel call is spawning all threads before the first loop over all objects.
Therefore all threads process all objects.
When the threads then loop over all indices, thread $n$ only processes the memory for the first volume dimension $i$ if:
\begin{align}
\begin{split}
    i \bmod N_{\text{Threads}} == n
\end{split}
\end{align}
% 
This operation results in a thread safe writable operation.
The only disadvantage is, that all threads have to check, if the \ac{AABB} is inside the \ac{VOI}.
However since with this configuration only one time threads are spawned, it is rather quick.
One has to be known, that the array is in order $x-y-z$, therefore the largest memory displacement is in x.
Therefore each thread is statistically (for a large volume) operating on its own shared memory (and cache).
% 
For large volumes bigger then the local shareable memory size the computation has to be split over multiple "nodes".
For this purpose \mpi is used.
Its slices the volume along the $x$-axis and $y-axis$ into blocks with a minimal surface area.
This is important for the next step (see \cref{sec:simulation}).
The data is know spit into different process and cannot be easyli be exchanged.
For the creation of the DV this is not necessary.
Each \mpi process can then create a discreticised sub volume as if it would be the hole volume.
However each sub volume has a additionally voxel along the $x$- and $y$-axis for later communication purpose (see \cref{sec:simulation}).
Each \mpi process can use \openmp to spawn multiple threads to efficiently use shared memory if the architecture supports it.
% 
% 
% 
\section{simulation}
\label{sec:simulation}
% 
The simulation pipeline runs the M\"uller-Stokes calculus on the precious calculated discretised volume. Since no scattering effects or refraction effects inside the tissue volume are included, each light ray trajectory follows a straight line.
The light matter interaction $\left( \prod_i R_i M_i R_i \times \vv{S} \right)$ is calculated. 
After the light ray reaches the end of the tissue the final optical elements (\eg polariser) are applied.
finally the light intensity is stored inside the resulting ccd-image array.\\
% 
The simulation allows a tiltable light beam.
The \ac{LAP} uses for this purpose a tiltible specimen.
The new designed microscop a tiltable light beam.
Both methods result in the same light path.
The tiltible specimen however results in a distorted view.
This distortion can be described by an affine transformation (see \cref{fig::affine_transformation}).
% 
\begin{figure}[!tb]
\centering
\resizebox{0.95\textwidth}{!}{
\input{gfx/pli/affine_transformation}}
\caption{affine transformation}
\label{fig::affine_transformation}
\end{figure}
% 
The simulation is able to calculate the distorted view (equivalent of the tiltible specimen) and the undistorted view (equivalent of the microscop. 
For the distorted view a so called "untilting" can be applied, which is a affine back transformation of the simulated image with linear interpolation (same as in the experiment).
% 
The simulation takes the effect of refraction of the tissue-air border into account.\footnote{glass adds only a parallel shift}
% 
To always get the same dens of light rays per ccd-pixel, all light ray starting positions are calculated from the ccd-pixels.
% 
\subsection{algorithm}
% 
\paragraph{calculation of light ray starting position}
% 
\begin{figure}[!tb]
% \centering
% 
\subcaptionbox{normal}[.495\textwidth]{
\resizebox{0.45\textwidth}{!}{
\def\tilt{0}
\def\nindex{2.25}
\inputtikz{gfx/simpli/tilting.tikz}
}}
% 
\subcaptionbox{tilted}[.495\textwidth]{
\resizebox{0.45\textwidth}{!}{
\def\tilt{20}
\def\nindex{2.25}
\inputtikz{gfx/simpli/tilting.tikz}
}}
\caption{side view tilting}
\label{fig:tilted_side_view}
\end{figure}
% 
% 
% 
% 
\begin{figure}[!tb]
% \centering
\def\azimuth{0}
\def\elevation{90}
\def\dz{2}
\savebox{\largestimage}{\resizebox{0.45\textwidth}{!}{\inputtikz{gfx/simpli/tilting_3d.tikz}}}
\subcaptionbox{camera view}[.495\textwidth]{
\usebox{\largestimage}
}
% 
\subcaptionbox{perspective view}[.495\textwidth]{
\raisebox{\dimexpr.5\ht\largestimage-.5\height}{%
\resizebox{0.45\textwidth}{!}{
\def\azimuth{20}
\def\elevation{25}
\def\dz{1}
\inputtikz{gfx/simpli/tilting_3d.tikz}
}}}
\caption[3d tilting]{3d tilting: around $xy$-axis, \raisebox{.25em}{\tikz \draw[red,thick](0,0)--(0.25,0);} top, \raisebox{.25em}{\tikz \draw[green!50!black,thick](0,0)--(0.25,0);} middle, \raisebox{.25em}{\tikz \draw[blue,thick](0,0)--(0.25,0);} bottom, \raisebox{.25em}{\tikz \draw[dash pattern=on 1.25pt off 1.25pt,thick](0,0)--(0.25,0);} original, \raisebox{.25em}{\tikz \draw[gray](0,0)--(0.25,0);} axis of rotation \TODO{improve images}}
\end{figure}
% 
% 
Snell's law describes the refraction of light between two different isotropic media:
\begin{align}
\begin{split}
    n_1 \sin{\Theta_1} = n_2 \sin{\Theta_2}
\end{split}
\label{equ:snell}
\end{align}
% 
The simulation uses as input parameter the refraction index of the tissue and the tilting angle to calculate the inner light angle.
From this the starting position of the light beam can be calculated (see \cref{fig:tilted_side_view}):
% 
First the light ray is backwords traversed starting at each ccd "pixel" (2).
Here the pixel size is equivalent to the voxel size.
Later the camera pixel size will be applied.
The light ray first hits the (tilted) tissue plane (2).
There its path is refrected according to Snells Law (\cref{equ:snell}).
From this the possition of the light at the bottom tissue plane (3) is calculated.
This is also the starting position of the light beam, since previous interactions do not require spatial information (\ie pol filter and $\lambda/4$-retarder).\\
% 
The ccd sensor and the tissue volume gets each their own coordinate system.
The ccd-sensor is described as a 2d plane.
The plane is rastered with a grid where each grid cell coresponds to a "pixel".
The light ray starts in the center of each "pixel", therefore a offset of $(\num{0.5}, \num{0.5})$ is added to the coordinate system for the geometric calculation.
The ccd-sensor index will be stored for each light ray in in case of a \mpi communication each process knows where to store the light intensity.\\
% 
The tissue coordinate system begins at the first array element with the index $(i=0, j=0, k=0)$.
The volume itself is specified by a dim-variable $(N_x, N_y, N_z)$.
Each voxel takes the space $[(i,j,k),(i+1,j+1,k+1))$ in space.
Therefore there is again a shift of \num{0.5} between the index and the center of each volume voxel.

% 
\paragraph{matrix calculus}
From the starting position the light tissue interaction will be calculated according to $\left( \prod_i R_i M_i R_i \times \vv{S} \right)$ (see \dummy).
Since the starting point is at the bottom of the tissue plain, and a light beam takes the step $s$ the physical property from $(x,y,z) + \frac{s}{2}$ is used (ZEICHNUNG).
For a non tilted view with a stept size equal to the voxel size this results in the indices values.
As long the light beam is inside the local (\mpi) tissue volume, everything can be calculated.
As soon as the light beam leaves the local volume it will be transfered to the appropriate mpi process.
If a linear interpolation of the properties is needed, the local volume gets in $x$ and $y$ direction an additional voxel.
With this "halo" the neighboring mpi process can also interpolate (with a distance of 1) the value.
Light which leaves the tissue / starts outside the tissue will be calculated with the background property.
% 
If the birefringence is 0 the multiplication of the M\"uller matrices is skipped and only the absorption is taken into account.
Since the M\"uller matrices are spasly (in this case), the calculation is optimized for this.
% 
\begin{lstfloat}[!tb]
	\lstinputlisting[language=c++]{code/simulation.cpp}
	\caption{Pseudocode simulation}
	\label{alg:simulation}
\end{lstfloat}
%
% 
\subsection{parallelisation}
There are several optimizations used inside this pipeline.\\
% 
First the order of the tissue stored inside the memory is along the z-axis.
This allows the light for the non tilted case along the z-axis and therfore along the memory.
therefore the data can be transferred linear to the cache and the prefetcher\footnote{A prefetcher get not only the data of the memory address i but also its neighbours i+1 and i-1 (depending on the order). This means the data is already in cache, if the next step is calculated. For linear traversions this means effectively a infinitive cache size.} of (modern) \ac{CPU} architectures hits its full potential.
This is also noticeable in the tilted view, since the tilting angle in the \ac{PLI}-experiment is rather small.
This reduces secnificantly the acces time of the \ac{CPU} and the \ac{RAM}.\\
% 
Secondly the main for loop for each light ray is parallized with \openmp.
This threads are completely separated and no race conditions exists.\\
% 
Additionally the same mpi topography is used from the DV-Generator (see \cref{sec:dv_generator}).
This is the reason the volume gets split into smaller parts with minimal surface area, since then the number of needed communications is also minimal.
In the previous \simpli implementatio the communication was not needed because the halo was as big that the light beam was never leaving the local volume.
This however meant, that for each tilted image the local volume had to be recalculated.
Also the memory consumption was much larger.
This yields in a quite big reduction of processing time. \footnote{so much, that the local memory is the bootlenek, not the cpu power.}\\
% 
At corners the light beam can travel through several \mpi volumes.
Therefore after each main loop the ommunication has to be done.
Then the main loop is repeated with all incomming light rays.
When no light rays are communicated anymore, the simulation is finished.
This is a rather small cost considering the saving of memory and for tissue section commenly thin tissue sections of \SI{60}{\micro\meter}.
% 
% 
% \lstinputlisting[language=c++, name=mpi_comm, caption={MPI code simulation}, label={alg:mpi_comm}]{code/mpi_comm.cpp}
% \begin{lstfloat}[!h]
% 	\caption{Pseudocode simulation}
% 	\label{alg:mpi_comm}
% \end{lstfloat}
% 
