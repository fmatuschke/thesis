\setcounter{chapter}{4}
\chapter{\acs{3D-PLI} simulation}
\label{cha:sof:simulation}
% 
% Interesse wecken: warum braucht man es, warum ist es kompliziert, lÃ¶sbare probleme
% 
% 
% \textcolor{gray}{
% Simulation are a technique which are getting more commonly used in this century.
% In literature it is knows as \name{in silico} meaning \say{performed on computer} where silicon stands for the silicon in computer chips.
% It is a analogy to \name{in vivo} (within the living), \name{in vitro} (in the glass) and \name{in sito} (on site), which are commonly used in biology and medicine.
% Simulations can be a cheaper and faster approach to doing experiments.
% However since the knowlege increases over time, the experiments and simulations bekome more and more compilacted.
% For simulations this usually means, more precise calculations and more effects have to be considered when doing predictions of the real world.
% If no mathematical shortcuts are developed or even exists this leads to more calculation intense and time consuming procedures.
% In the past Moores Law was a good thriver to be able to do more expensive calculations.
% However currently the computer chips are physically at there limit with a few nanometer at scale (at least in 2d).
% Also the clock frequency is almost at its limits since at that scale the \say{wires} inside the chips become more conductive because they behave as a capacitor.
% Additionally quantum effects like tunneling become another barrier since they introduce error currents.
% \\
% % 
% Since about one decade \acs{GPU} become more and more commonly used in simulations and other algorithms.
% They have the advantage of calculate a lot of parallel instructions at the same time.
% However they come with the cost of being (at least for now) slower than a \ac{CPU}.
% \\
% % 
% Further then that only super computers can help to solve the high demand on computer power needed.
% }
% \par
% 
% 
In the past simulation of \ac{3D-PLI} already shown their capabilities \cite{Dohmen2015,Menzel2015,Menzel2016,Menzel2020,Menzel2021,MenzelMaster,MenzelDissertation}.
In the case of scattering finite-difference time-domain simulations the here presented algorithm to design new collision free fiber models allowed for the first time to simulate the effect of scattering light without any superposed interference signals.
This allowed the understanding of scattering effects due to the configurations of fiber bundles and crossings as well as the transmittance change for inclined fiber configurations.\cite{MenzelDissertation,Menzel2020,Menzel2021}.
%  
In the case of the simulation of linear optics the optical system could repoduse the experimental results with \eg{} the optical resampling process \cite{Dohmen2015,Menzel2016}.
However this algorithm is very computational heavy and due to the precalculations of a discretised tissue volume, very memory intense.
The foundations of a more ffitient parallel algorithm for the use of supercomputer was already elaborated \cite{Lucksch2016}.
However, the new tilting design resulted in a simplification of the former simulation that could not be easily integrated.
Therefore the algorithm was completely redesigned and rewritten.
Additionally the here presented fiber models had to be Incorporated as well.
Finally the descision was made, to switch to the M\"uller Stokes calculus to allow the \dummy{} of filter \dummy{}.
% 
\par
% 
The Simulation is split into two consecutive parts: the volume discretizer and the simulation.
The volume discretizer discretises the virtual nerve fiber models onto a cartesian grid, which is then in the second step used to calculate the light matter interaction.
One parallelization technique allows to split the volume onto different \acp{CPU} or nodes.
Due to the tilting approach, the light vector needed to be able to leave the current volume of a single \ac{CPU} and traverse to the next volume/\ac{CPU}.
This simulation as well as the optical \dummy{} of the system and the inclination analysis will be \dummy{} here.
\\
% 
The code is as the former written in \cpp{} with a user friendly wrapper function in \python{}.
% 
\dummy[wohin mit den zukunftsplaenen? -> ende]{}.
% 
% 
% The here presented \fastpli{} software package allows to predict \ac{3D-PLI} experiments within the \python package \pymodule{fastpli.simulation} by means of linear optics \cite{} and 3d fiber models \cite{}.
% It is based on the previous develop tool \simpli{} \cite{Dohmen2015}, which was then further developed and already parallel for the use on the super computers by multiple \acp{CPU} \cite{Lucksch2016}.
% This version however uses M\"uller matrices \cite{} to define the optical elements and the Stokes vector \cite{} for describing the light \cref{sec:Mueller-Stokes}.
% %
% The further development of the algorithm will be described in the following.
% \par
% % 
% The following procedures are described in this chapter:
% \begin{itemize}[nosep]
%     % \item overview
%     \item model discretization technique
%     \item simulation
%     \item optic imitation 
%     \item analysis
%     \item optimization
% \end{itemize}
% % 
% The computational heavy calculations of the discretization and simulation part are written in \cpp{} which are wrapped inside a \python{} class \code{simpli} for user friendly interactions.
% The additional algorithms of the optic are written in \python{}.
% % 
% \par
% % 
% The \ac{3D-PLI} Simulation is in its \ac{CPU} version\footnote{At the end of the dissertation Alexander Kobush developed a GPUsimPLI approach under my supervision \cite{}.} split into two parts.
% The first part called \name{Generation} \todo{name} generates a discretizied 3d volume of the nerve fiber models from \cref{chap:modelling}.
% This means that all properties \eg{} optical axis are saved in a 3d array.
% This \say{volume} is then later be used to perform the light matter interaction by means of linear optic described in \cref{sec:theory}.
% Last but not least the light interaction with the \ac{CCD}-Sensor will be performed inside the \pymodule{fastpli.simulation.optic} module.
% The resulting data correspond the a \ac{3D-PLI} row data image.
% Further analysis algorithms are implemented
% With these the same type of analysis as in the \ac{3D-PLI} experimental analysis can be achieved.
% All Algorithms are combined inside a \python{} class called \pymodule{fastpli.simulation.simpli}.
% Inside is everything to perform a pipeline code as well as full control about every step inside the pipeline.\todo{veroffentlichung in intro}
% 
\section{DV-Generator}
\label{sec:dv_generator}
% 
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.5\textwidth}
\inputtikz[true]{gfx/simpli/disc_volume}
\caption[discreticed tissue volume]{discretized tissue volume: Its \dummy{} is defined by a \ac{AABB}, which is defined by two variables. \itodo{show x,y,z resulting volume?}\itodo{show fiber model inside?}}
\label{fig:discVol}
\end{figure}
% 
\itodo{better name}
% 
The idea of the simulation is to first calculate a so called \say{discretised tissue volume}.
It represents a discrete constant voxel model of the tissue.
This helps to drastically speed up the light matter interaction of the next step (see \cref{sec:simulation}).
\par
% 
The discreticed tissue volume represents a cuboid sliced into equal sized smaller cubes called voxels, \ie 3d pixels (see \cref{fig:discVol}).
Each voxel contains the physical properties of the tissue inside its current position.
The overall volume is limited by an \ac{AABB} or \ac{VOI}, which is defined by a minimal and maximal value $\voi = [(x_{\mathit{min}}, y_{\mathit{min}}, z_{\mathit{min}}),(x_{\mathit{max}}, y_{\mathit{max}}, z_{\mathit{max}})]$.
Additionally the \voxelsize{} parameter \voxels{} is set to a floating point number and defines the edge length of the voxels.
If the division of the \voi{} by the \voxelsize{} is not an integer, the \voi{} is automatically increased to the next possible integer value to avoid boundary effects.
% 
% 
% 
\subsection{Nerve fiber layers}
% 
As described in \dummy{} nerve fibers are axons, which can be wrapped around by several windings of myelin (see \cref{fig:fiberLayer}).
Especially for light wave simulations the myelin windings are a significant property \cite{MenzelDissertation}.
This makes it necessary to be able to build such a structure.
\par
% 
An easy implementation is to represent the windings as layers (see \cref{fig:myelinLayer}).
This simplifies the creation process significantly.
A layer can then simply defined by a factor between $0$ and $1$, which scales with the nerve fiber radius.
For example, $\code=0.75$ means that from $0\leq r < 0.75$ of the radii are interpreted as the first layer.
\par
% 
Each layer needs to its radius also a set of physical properties:
% 
\begin{itemize}[nosep]
    \item birefringence value $\dn$
    \item absorption coefficient $\mu$
    \item optical axsis model $p=\mathit{parallel}$, $r=\mathit{radial}$, $b=\mathit{background}$
\end{itemize}
% 
These properties are set as a list of tuples inside the algorithm (see \cref{alg:fiberbundleprops}).
% 
\begin{lstfloat}[!ht]
\lstset{style=python}
\begin{lstlisting}[]
fbs_properties = [[(r, dn, mu, 'p'), (second layer), ...],
                  [(first layer of second bundle), ...],
                  [...]]
\end{lstlisting}
\caption[Fiber bundle properties]{Defining fiber bundle properties.}
\label{alg:fiberbundleprops}
\end{lstfloat}
% 
At the end the DV-Generator returns the arrays \tissue{}, \opticalaxis{} and the \propertylist{} for the use of the simulation.
% 
\subsection{Discretizing a nerve fiber model}
% 
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.32\textwidth}
\subcaptionbox{\label{fig:myelinLayer}Schematic of nerve fiber with axon and wrapped around myelin}[.32\textwidth]{
\resizebox{!}{0.32\textwidth}{
\includegraphics[]{dev/brain/myelin_layers.pdf}}}
\subcaptionbox{\label{fig:fiberLayer}Cross section nerve fiber with layerd structure definde by $n$ radii}[.32\textwidth]{
\inputtikz[true]{gfx/simpli/fiber_layer}}
\subcaptionbox{\label{fig:vectormodel}Cross section of discreticed nerve fiber with resulting vectors of optical axis}[.32\textwidth]{
\inputtikz[true]{gfx/simpli/vector_model}} \hfill
\caption{Discretisation of nerve fiber with layered structure.}
\label{fig:fiber_discretisation}
\end{figure}
% 
To discretize nerve fiber models (see \cref{chap:sof:modelling}) one can start with the discretization of a single nerve fiber segment, since a fiber is a chain of consecutive segment.
The idea is, that if a voxel is inside a fiber segment, it will be marked as a tissue with the physical properties (absorption, optical axis and birefringece) from the voxels center position $\vec{q}$ (see \cref{fig:fiber_discretisation}).
In this context \say{a voxel inside a fiber segment} means, that its center point is inside the volume of the fiber segment.
The discretized tissue is designed in such a way that, that the arrays position $[i,j,k]$ takes up the space of $(i,j,k)$ to $(i+1,j+1,k+1)$ in the unit of \voxelsize{}.
\par
% 
Therefore the filling process can be integrated by looping over all voxels in the current volume.
However since a single nerve fiber segment is usually much smaller than the volume, it makes sense to reduce the size of the iterating voxels.
This is easily be done by only iterating over the voxels of the \ac{AABB} of the nerve fiber segment.
\par
% 
Now each voxel will be checked, if it is inside the nerve fiber segment.
This is analog calculated to the collision between two nerve fiber segment (see \cref{alg:pseudocodeCollisionDetection}) except that only one point of the closest distance has to be found.
The other one is the voxels center position $\vec{q}$.
From this calculation the not only the closes point \dummy{} will be returned, but also the distance vector \dummy{}. 
This helps to calculate the the distance, which will be used to check if the voxel is inside the fiber segment, and if it is, in wich layer of the fiber segment it is.
Additionally the distance vector can be used, if the optical axis inside the current layer is set to a microscopic \dummy{}, which means that the optical axis is orientated radial to the fiber segment.
\par
% 
Two values have to be stored in the case of a valid entry.
The first one is an index inside a \code{tissue} array, which is later used to retreve the properties from a list with the same index order.
The second one is the orientation of the optical axis inside the current layer.
The orientation is either parallel to the fiber segment in case of the macroscopic model, or radial in the case of the microscopic model.
A layer can also be marked as \say{background}, which will allow the user to specify a region with absorption, but without a birefringence.
\par
% 
Before looping over all fiber segments, an additional problem has to be solved.
Since two consecutive fiber segments will take up the same space because they share a point, they also will fill the voxel of the tissue volume.
This is a problem, since now the second fiber segment will overwrite the values of the first one.
This can easily be solved by adding an additional array, which will store the smallest distance inside, which was calculated when filling the voxels space.
The values will now be overwritten, if a new smallest distance was calculated, which is smaller then the already stored one.
This also solves the problem, that at the end end points of a fiber segment in the case of a radial optical axis model, the optical axis would be \say{star like}.
This of course will still be the same at the beginning and end of an fiber.
\par
% 
This \say{filling} loop is represented in the pseudocode \cref{alg:fiberbundleprops}.
% 
\begin{lstfloat}[!tb]
\lstset{style=python}
\begin{lstlisting}[]
for fiber_segment in fiber_bundle:
    for i,j,k in fiber_segment.aabb().voxels():
        min_dist, min_point = calculate_min_distance((i,j,k), cc)
        if min_dist < cc.radius:
            if min_dist < current_distance[i,j,k]:
                optical_axis[i,j,k,:] = get_axis_orientation(
                                            (i,j,k), min_dist,
                                            min_point)
                tissue[i,j,k] = get_layer_id(min_dist)
                current_distance[i,j,k] = min_dist
\end{lstlisting}
\caption{Discretized volume filling algorithm}
\label{alg:fiberbundleprops}
\end{lstfloat}
%
\itodo{the length of the stored optical axis vector is interpreted as strength. In this model the length is always 1. If the user wishes to add variability, he/she can do this by changing the length of the vectors inside the arrays.}
% 
% 
% 
\subsection{\voxelsize{}}
% 
\begin{figure}[!t]
\centering
\resizebox{1.0\textwidth}{!}{
\tikzset{external/export=false}
\input{gfx/simpli/vector_error}}
\caption[Discretization error]{Discretization error. Cross section of single fiber with one myelin layer inside discretized tissue volume. The couloured pattern show the resulting voxels which corresponds to the fiber. The smaller the \voxelsize{}, the smaller the representation error.}
\label{fig:vectorfield_disc_error}
\end{figure}
% 
The \voxelsize{} parameter is the most important property of the simulation.
It will determine, how accurate the simulation is \dummy{}. 
This is first of all because it will change the number of voxels with which the nerve fiber model is discretized (see \cref{fig:vectorfield_disc_error}).
Especially for the case of multiple layers this will have an major impact.
Additionally it will also change the \stepsize{} of the light through the tissue.
Usually the \stepsize{} is the same as the \voxelsize{}, but the user can change it if necessary.
Also the number of light particels will increase with decreasing \voxelsize{} since for about each voxel at the bottom of the tissue a single light particle will be casted (see \cref{sec:pathOfLight}).
Therefore the resulting intensity signal will also be more accurate.
% 
% 
%  
\subsection{optimization}
% 
All arrays are implemented as contiguous c-arrays, which are accessible as \name{Numpy}-arrays from outside without the need to copy the data.
Since these arrays grow with $\mathcal{O}(n^3)$, the aim was to make them movable through the \cpp{} libraries as well as in \python{}.
The memory order of the arrays is in $x\text{-}y\text{-}z$ direction, so the largest memory shift is in $x$ and the smallest in $z$.
This was chosen so that later in the simulation part, where the light travels mainly in $z$-direction, the memory is aligned to the required information and thus the \acp{CPU} cache prefetcher can be used.
\par
% 
Two methods are used to parallelize the algorithm on the \ac{CPU}.
The first uses \openmp{} to parallelize the filling of the \ac{AABB} volume of each object.
The second uses \mpi{} to allow distribution to multiple \ac{CPU} cores without sharing memory (detailed description in \cref{sec:mpiSim}).
\par
% 
The parallelization of filling the voxels of the discretized volume leads to a race condition if several threads want to write or read to the same memory address (or coordinate) (\eg{} two objects occupy the same space).
A solution with a lock would be very slow since, depending on the fiber segment length and orientation, most voxels of the \ac{AABB} have to be written to.
Also since many of the voxels don't need to be overwritten, most locks would be unnecessary.
\\
Since the loop runs over all $(i,j,k)$ indices of the three space dimensions, the parallelization can be done using the iteration over the voxels themself per fiber segment.
However, this leads to a slow implementation because new threads have to be spawn for each fiber segment, which takes quite some time.
If was therefore decided, that the parallel call creates all threads before the first loop over all objects.
This means all threads process all objects.
If the threads then execute a loop over all indices (or coordinates), thread $n$ only processes the memory for the first volume dimension $i$ if (see \cref{fig:discVolThread}):
% 
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.5\textwidth}
\inputtikz{gfx/simpli/disc_volume_thread}
\caption[discretized volume parallelization]{discretisation volume parallelization with \openmp{}. Each thread handles every n-th yz-section. This ensures both thread safety and that the workload is more balanced, even with an inhomogeneous.}
\label{fig:discVolThread}
\end{figure}
% 
\begin{align}
\begin{split}
    i \bmod N_{\mathit{Threads}} == \mathit{thread}_{\mathit{id}}
\end{split}
\end{align}
% 
This process results in a thread-safe writable operation.
The only drawback is that all threads must check if the \ac{AABB} is inside the \ac{VOI}.
However since with this configuration only once threads are spawned, and the \ac{AABB} collison check is very efficient in terms of computation time, it is quite fast.
Additionally the shared cache of the \acp{CPU} can speed up the memory retrieving process as well, if the \acp{CPU} workload do not differ that much.
\par
\paragraph{Note}
Depending on the scice of the volume and the acessable memory, the user is adviced to distribute the \openmp{} parallelization and \mpi{} distribution \dummy{}.
The \openmp{} speedup is usually as fastest if the spawend threads are located on the same physical \ac{CPU} or even inside the same \acp{CPU} which uses the same cache.
It can therefore be that the speedup is increased by reducing the \openmp{} threads and by increasing the \mpi{} threads instead \todo{better mpi implementation?}.
% 
% 
% 
\section{Simulation}
\label{sec:simulation}
% 
The simulation algorithm executes the M\"uller-Stokes calculus (see \cref{sec:Mueller-Stokes}) on the previously calculated discrete volume (see \cref{sec:dv_generator}) for a light beam along its path.
Since no scattering or refraction effects are included in this simulation, each light path follows a straight line.
The interaction of light matter is calculated according to $\left( \prod_i R_i M_i R_i \cdot \vec{S} \right)$ (see \cref{sec:mueller_stokes}). 
Befor the light vector is multiplied by the polarizer of the optical system.
After the light beam has reached the end of the tissue, the last optical elements are taken into account.
Finally, the light intensity is stored in the \acs{CCD} image array, which has at this point the same size as the 2d $xy$-grid of the discretized tissue.
At the end it will be resampled to the final \ac{CCD} array size and a noise model will be applied.
% 
%
\subsection{Path of light}
\label{sec:pathOfLight}
% 
\begin{figure}[!t]
\def\tikzheight{0.42\textwidth}
\subcaptionbox{camera view}[.49\textwidth]{
\inputtikz{gfx/simpli/tilting_3d_a}}\hfill
\subcaptionbox{perspective view}[.49\textwidth]{
\inputtikz{gfx/simpli/tilting_3d_b}}
\tikzset{external/export=false}
\caption[3d tilting]{3d tilting: around $xy$-axis, \raisebox{.25em}{\tikz \draw[red,thick](0,0)--(0.25,0);} top, \raisebox{.25em}{\tikz \draw[green,thick](0,0)--(0.25,0);} middle, \raisebox{.25em}{\tikz \draw[blue,thick](0,0)--(0.25,0);} bottom, \raisebox{.25em}{\tikz \draw[dash pattern=on 1.25pt off 1.25pt,thick](0,0)--(0.25,0);} original, \raisebox{.25em}{\tikz \draw[gray](0,0)--(0.25,0);} axis of rotation \itodo{test david und daniel}}
\label{fig:tilting_camera_view}
\end{figure}
% 
The simulation allows a tiltable light beam.
For this purpose, the \ac{LAP} uses a tilting stage to which the tissue sections are attached (see \cref{fig:tilted_side_view}). 
The newly designed microscope on the other hand has a already tilted light beams.
There are generated by an conical light path, from which then with an aperture the desired light orientation is sampled (see \cite{Wiese:887678}).
Both methods yield within a good approximation to the same light paths.
\\
% 
The tilting can lead to a distortion of the image (see \cref{fig:tilting_camera_view}).
This distortion can be described by an affine transformation (see \cref{fig::affine_transformation}):
% 
\begin{figure}[!t]
\centering
\input{gfx/pli/affine_transformation}
\caption{affine transformation}
\label{fig::affine_transformation}
\end{figure}
% 
\begin{align}
f(\vec{x}) = \mat{A} \cdot \vec{x} + \vec{t}
\end{align}
where $\vec{x}$ the coordinate input, $\mat{A}$ and $\vec{t}$ the transformation values and $f(\vec{x}$ the transformed coordinate.
\\
% 
The simulation is able to take the distorted view into account and it can resample the starting positions of the light beams such, that the distortion is reversed.
It is the same as distorting the \ac{CCD} sensor, however without the need of interpolation of the \ac{CCD} image sensor.
In the case of simulating the distortion, the affine inverse transformation $f^{-1}(\vec{x}) = \mat{A}^{-1} \cdot \vec{x} - \vec{t}$ can be applied.
However, this leads to interpolation artifacts.
Therefore both techniques exists to be able to study this effect in more detail.
\par
% 
An additional effect is the simulation of the refraction of the tissue-air border, which is described by Snell's law for isotropic media (see \dummy{})
Since this only adds a parallel shift, a simulation is only necessary if the resampling of an image registration is to be studied.
\par
% 
\begin{figure}[!t]
\def\tikzwidth{0.42\textwidth}
\subcaptionbox{normal}[.495\textwidth]{
\def\tilt{0}
\def\nindex{2.25}
\inputtikz[true]{gfx/simpli/tilting_a}}\hfill
\subcaptionbox{tilted}[.495\textwidth]{
\inputtikz[true]{gfx/simpli/tilting_b}}
\caption[Light path]{Ligh path.}
\label{fig:tilted_side_view}
\end{figure}
% 
The starting position of the light beam can be calculating by traversing the light path backwards (see \cref{fig:tilted_side_view}).
Each light beam $\vec{l}_0$ hitting the \ac{CCD}-array element, not resampled yet to the actual \ac{CCD} pixel size, can be traversed back to the tissue top plane $\mathfrak{S}_{top}$.
Next the light beam $\vec{l}_1$ is traversed back through the tissue to the bottom plane $\mathfrak{S}_{bottom}$.
The point on the bottom tissue plane corresponds to the starting position of the light beam.
In the case of a tilted light beam or lilted tissue, a offset of $\Delta$ is occurs.
\todo{The backtracking of the light from the ccd array is better so that in the resampling process no boarder effects can occurs}
\\
% 
In the case of already simulating an undistored view, the light paths have to spaced out by the same distance, as the affine transformation would resample the resulting pixels.
% 
\begin{lstfloat}[!ht]
	\lstinputlisting[style=cpp,basicstyle=\scriptsize\ttfamily,]{code/simulation.cpp}
	\caption{Pseudocode simulation \itodo{anhang}}
	\label{alg:simulation}
\end{lstfloat}
% 
\subsection{Tissue voxel interpolation}
% 
\begin{figure}[!t]
\centering
\def\tikzwidth{0.75*\textwidth}
\inputtikz[true]{gfx/simpli/vector_interpolation}
\tikzset{external/export=false}
\caption[Illustration linear and spherical interpolation.]{Illustration of difference between linear and spherical interpolation. Linear interpolation has a constant distance $s$ between each point, spherical interpolation a constant angle $\varphi$ for the same $dt$.}
\label{fig:vectorfield_disc}
\end{figure}
% 
For a \stepsize{} unequal to the \voxelsize{} or a tilted light path the midpoint does not match the center point of the voxel anymore.
This means, that the physical properties stored in the arrays have to be interpolated.
There are currently three interpolation methods for this purpose implemented: \textit{nearest neighbor}, \textit{linear interpolation} and \textit{spherical interpolation}. 
The voxels taken into account for the interpolation are the nearest 8 adjacent voxels, so array indices $(\floor{x\pm0.5},\floor{y\pm0.5},\floor{y\pm0.5})$.
% 
The \textit{nearest neighbor} is the most error-prone of the three methods and should be not to be used. 
However it is also the fastest method.
The \textit{linear interpolation} was the first one implemented.
However since the data contain orientation data, the \textit{spherical interpolation} method should be used.
\\
% 
\begin{figure}[!t]
\centering
\includegraphics[width = 0.5\textwidth]{dev/wiki/1280px-3D_interpolation2.png}
\caption[Trilinear interpolation]{Trilinear interpolation \url{https://en.wikipedia.org/wiki/Trilinear\_interpolation}.}
\label{fig:triInterp}
\end{figure}
% 
To interpolate the data the trilinear interpolation will be performed (see \cref{fig:triInterp}).
% 
% 
\subsection{algorithm}
% 
\par
\noindent\rule{\textwidth}{2pt}
\par
% 
First the starting points of all light beams will be calculated.
hen each light beam can be traversed inside the tissue.
To calculate the light matter interaction, the ... will be calculated after each light beam step.
As soon as the light hits the boarder of the tissue, the light beam will be the last optical elements and the intensity will be stored inside the \ac{CCD} array.
% 
% 
% 
\subsection{parallelisation}
% 
There are several optimizations used inside this pipeline.
\\
% 
First the order of the tissue stored inside the memory is along the z-axis.
This allows the light for the non tilted case along the z-axis and therefore along the memory.
therefore the data can be transferred linear to the cache and the prefetcher\footnote{A prefetcher get not only the data of the memory address i but also its neighbours i+1 and i-1 (depending on the order).
This means the data is already in cache, if the next step is calculated.
For linear traversions this means effectively a infinitive cache size.} of (modern) \ac{CPU} architectures hits its full potential.
This is also noticeable in the tilted view, since the tilting angle in the \ac{3D-PLI}-experiment is rather small.
This reduces significantly the access time of the \ac{CPU} and the \ac{RAM}.\\
% 
Secondly the main for loop for each light ray is parallized with \openmp{}.
This threads are completely separated and no race conditions exists.\\
% 
Additionally the same mpi topography is used from the DV-Generator (see \cref{sec:dv_generator}).
This is the reason the volume gets split into smaller parts with minimal surface area, since then the number of needed communications is also minimal.
In the previous \simpli{} implementation the communication was not needed because the halo was as big that the light beam was never leaving the local volume.
This however meant, that for each tilted image the local volume had to be recalculated.
Also the memory consumption was much larger.
This yields in a quite big reduction of processing time.
\\
% 
At corners the light beam can travel through several \mpi{} volumes.
Therefore after each main loop the communication has to be done.
Then the main loop is repeated with all incoming light rays.
When no light rays are communicated anymore, the simulation is finished.
This is a rather small cost considering the saving of memory and for tissue section commonly thin tissue sections of \SI{60}{\micro\meter}.
% 
\itodo{smart sampling spaeter diskutieren}
% 
\subsection{Optic}
\label{sec:ccdOptic}
% 
The image sensor is a \ac{CCD} image sensor.
A general \ac{CCD} sensor consits out of an array of capacitors.
In each capacitor an electric charge will be stored, setted free by an incoming photons.
After a read out process, which also contains a electric gain, the resulting values can be stored as an image.
This process has two major noise parts. The first is the electic charge.
Its value is, as long as it is not saturated, linear correlated with the number of photons.
However internal noise like thermal, and a each photon statistically charges a number of electrons, the resulting capacity varies.
The second major noise comes from the gain process.
Here the electric voltage will be gained before a analog digital read out.
This process is also strong linear correlated around a operational point.
However due to the nature of the underlining circuit, i.e. usually transistors and their power source, the resulting value can vary.
All noise sources combined yield to an poison distributed noise, to too the nature of digital values.
%
\\
%
To account for the optical setup, three things have to be done.
\paragraph{Bluring}
The optical resolution the light rays have to be blurred.
This is classically done via a 2d gaussian convolution.
\paragraph{Sampling}
Since the number and final position of the light rays is according to the voxels, all intensities of an image pixel have to be combined.
Here it is done via a mean value sampling.
This in contrast to resizing, does not interpolates the image.
% 
\paragraph{Noise}
The last step is to replicate the noise of the image setup. To account for this a noise model has to be applied to each image pixel. \cite{Wiese:887678} showed that this can be done via a poisson/gaus model.
% 
% 
% 
\section{\mpi{} parallelization}\label{sec:mpiSim}
\begin{figure}[!t]
\centering
\def\tikzwidth{0.75\textwidth}
\inputtikz{gfx/simpli/com_halo}
\caption{comunication halos. The volume is split into six subvolumes, distributed to 6 mpi ranks. The coloured voxels have the same tissue information.}
\label{fig:com_halo}
\end{figure}
% 
For huge volumes that are larger than the locally optimal shared memory size, the calculation must be split into several physical \acp{CPU} or \name{computation nodes}.
For this purpose \mpi{} is used.
A method is implemented that automatically divides the volume along the $x$ axis and $y- axis$ into blocks with minimal surface area (see \cref{fig:com_halo}).
This is important for the following simulation step (see \cref{sec:simulation}).
Each \mpi{} process can then create a discretized sub-volume as if it were the hole volume.
However, each sub-volume has an additional voxel along the $x$ and $y$ axis for later communication purposes as \name{halo}. (see \cref{sec:simulation}).
Each \mpi{} process can additionally use \openmp{} to create multiple threads for efficient use of shared memory if the architecture supports it.
% 
% 
% 
\section{Analysis}
% 
The same algorithms are implemented as in the \ac{3D-PLI} routine pipeline \dummy[-> theory]{}.
This are the following.
% 
\begin{itemize}
  \item Fourie Analysis: resulting in the three image modalities: transmittance, direction and retardation \dummy{}. 
  \item Tilting Analysis: implementation of the \ac{ROFL} algorithm by \cite{Schmitz2018} \dummy{}. 
  \item \ac{FOM} \dummy{}. 
\end{itemize}
% 
% \section{Pipeline}
% % 
% \begin{lstfloat}[!tb]
% \centering
% \scalebox{0.75}{
% \begin{minipage}{\the\textwidth}
% \lstinputlisting[style=python]{code/pipeline.py.tex}
% \end{minipage}}
% \caption[simpli pipeline]{Pipeline}
% \label{alg:Pipeline}
% \end{lstfloat}
% % 
% A pipeline code is implemented which combines all steps above (see \cref{alg:Pipeline}).
% It allows by minimal ... a fully run of the simulation as close to the \ac{3D-PLI} setup and its analysis pipeline.
% All results can be accessed and be stored inside a \textit{h5} container file.
