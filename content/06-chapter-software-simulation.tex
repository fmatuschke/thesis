\setcounter{chapter}{5}
\chapter{\acs{3D-PLI} Simulation}
\label{cha:simulation}
% 
Simulation are a technique which are getting more commonly used in this century.
In literature it is knows as \name{in silico} meaning \say{performed on computer} where silicon stands for the silicon in computer chips.
It is a analogy to \name{in vivo} (within the living), \name{in vitro} (in the glass) and \name{in sito} (on site), which are commonly used in biology and medicine.
Simulations can be a cheaper and faster approach to doing experiments.
However since the knowlege increases over time, the experiments and simulations bekome more and more compilacted.
For simulations this usually means, more precise calculations and more effects have to be considered when doing predictions of the real world.
If no mathematical shortcuts are developed or even exists this leads to more calculation intense and time consuming procedures.
In the past Moores Law was a good thriver to be able to do more expensive calculations.
However currently the computer chips are physically at there limit with a few nanometer at scale (at least in 2d).
Also the clock frequency is almost at its limits since at that scale the \say{wires} inside the chips become more conductive because they behave as a capacitor.
Additionally quantum effects like tunneling become another barrier since they introduce error currents.
\\
% 
Since about one decade \acs{GPU} become more and more commonly used in simulations and other algorithms.
They have the advantage of calculate a lot of parallel instructions at the same time.
However they come with the cost of being (at least for now) slower than a \ac{CPU}.
\\
% 
Further then that only super computers can help to solve the high demand on computer power needed.
\\[\baselineskip]
% 
The here presented \fastpli{} software package allows to predict \ac{3D-PLI} experiments within the \python package \pymodule{fastpli.simulation} by means of linear optics \cite{} and 3d fiber models \cite{}.
It is based on the previous develop tool \simpli{} \cite{Dohmen2015}, which was then further developed and already parallel for the use on the super computers by multiple \acp{CPU} by Sonja Lucksch \cite{Lucksch2016}.
This version however uses M\"uller matrices \cite{} to define the optical elements and the Stokes vector \cite{} for describing the light \cref{sec:Mueller-Stokes}.
%
The further development of the algorithm will be described in the following.
\\[\baselineskip]
% 
The following procedures are described in this chapter:
\begin{itemize}[nosep]
    % \item overview
    \item model discretization technique
    \item simulation
    \item optic imitation 
    \item analysis
    \item optimization
\end{itemize}
% 
The computational heavy calculations of the discretization and simulation part are written in \cpp{} which are wrapped inside a \python class \code{simpli} for user friendly interactions.
The additional algorithms of the optic are written in \python 3.
% 
\\[\baselineskip]
% 
The \ac{3D-PLI} Simulation is in its \ac{CPU} version\footnote{At the end of the dissertation Alexander Kobush developed a GPUsimPLI approach under my supervision \cite{}.} split into two parts.
The first part called \name{Generation} \todo{name} generates a discretizied 3d volume of the nerve fiber models from \cref{chap:modelling}.
This means that all properties \eg{} optical axis are saved in a 3d array.
This \say{volume} is then later be used to perform the light matter interaction by means of linear optic described in \cref{sec:theory}.
Last but not least the light interaction with the \ac{CCD}-Sensor will be performed inside the \pymodule{fastpli.simulation.optic} module.
The resulting data correspond the a \ac{3D-PLI} row data image.
Further analysis algorithms are implemented
With these the same type of analysis as in the \ac{3D-PLI} experimental analysis can be achieved.
All Algorithms are combined inside a \python{} class called \pymodule{fastpli.simulation.simpli}.
Inside is everything to perform a pipeline code as well as full control about every step inside the pipeline.
% 
\section{DV-Generator}
\label{sec:dv_generator}
% 
First the volume has to be defined.
The simulated/discretizied volume is limitied by a \ac{AABB}.
The \code{voxel\_size} is set to a floating point number and defines the edge length of the discretized voxels.
Next the each voxel has to be set with is physical properties.
\\
% 
To calculate a discrete volume of optical properties from a fiber configuration, the same fiber representation as in \cref{sec:nerve_fiber_representation} is used, \ie{} a list of lists of 4d coordinates.
The first list inherits nerve fiber bundles.
The second inner list the nerve fibers.

Since all objects are \ac{CC}, the problem of discretisation can be therefore reduced to the case of a single \ac{CC} object $(\vv{p_i}, \vv{p_{i+1}}, r_i, r_{i+1})$.
% 
Since the birefringend orientation inside a fiber can be represented either with the micro or marcoscopic model (see \dummy{}), the radial or parallel orientation for a point $q$ to the object has to be calculated.
In the case of parallel orientation the orientation $o$ is:
\begin{align}
\begin{split}
    o = \frac{\vv{p}_i - \vv{p}_{i+1}}{\abs{\vv{p}_i - \vv{p}_{i+1}}}
\end{split}
\end{align}
% 
For the radial case the smallest distance to the line segment $(\vv{p}_i,\vv{p}_{i+1})$ has to be calculated (analog to \cref{sec:collisionDetection}) \todo{and for the distance value}.
% 
\begin{figure}[!t]
\centering
\def\tikzwidth{0.625\textwidth}
\inputtikz{gfx/simpli/vector_model}
\caption{discretisation of fiber}
\label{fig:fiber_discretisation}
\end{figure}
% 
\begin{figure}[!tb]
\centering
\def\tikzwidth{0.33\textwidth}
\inputtikz{gfx/simpli/indexing}
\caption{indexing of arrays.
The vector inside the array at index position $[i,j,k]$ will correspond to the vector at position $p=(i+0.5,j+0.5,k+0.5)\cdot \mathit{\voxelsize}$}
\label{fig:indexing_array}
\end{figure}
% 
The radial orientation vector is then parallel to the smallest distance vector $\vv{d}$.
The distance is also used to check which layer of the fiber is "active" (\eg axon or myelin). 
% 
% 
\paragraph{Fiber layers and their properties}
Each nerve fiber bundle needs to be characterized by the corresponding physical parameters.
These parameters are 
\begin{itemize}[nosep]
    \item absorption coefficient $\mu$
    \item birefringence value $\dn$
    \item optical axsis model $p=\mathit{parallel}$, $r=\mathit{radial}$, $b=\mathit{background}$
\end{itemize}
%
\begin{lstfloat}[!tb]
\lstset{style=python}
\begin{lstlisting}[]
fbs_properties = [[(layer_scale, dn, mu, 'p'), (second layer), ...],
                  [(first layer of second bundle), ...],
                  [...]]
\end{lstlisting}
\caption{Definig fiber bundle properties}
\label{alg:pseudocode_octree}
\end{lstfloat}
% 
These parameters have to set for every layer (see \todo{bild erzeugen}) inside the fiber.
A \code{layer} is a concept to allow such things as differentiate between axon and myelin or multiple layers of myelin with intracellular fluid between the windings.
Therefore the parameters have to be set in the following way (see \cref{alg:pseudocode_octree})
% 
The \code{layer\_scale} is a factor of how much of the radii will be set to this layer.
E.\ g. $\code{layer\_scale}=0.75$ means that from $0\leq r < 0.75$ of the radii will be interpret as the first layer.
The value can even be set to values $>1$ if the user whishes to.
Of course then a collision free model is not guarantee to be any more collision free.
% 
The \ac{CC} object has the following \ac{AABB}:
\begin{align}
\begin{split}
    \sum_{1,2,3} \epsilon_{i,j} \times \hat{e}_i \times \max(p_{0,j}, p_{1,j}) + \max(r_0, r_1)
\end{split}
\end{align}
To calculate the discreticed voxels, this \ac{AABB} is iterated. for v in V(AABB): \dummy{}
% 
Iterating over all voxels and afterwords over all objects of all fibers yield in the discretisec volume model.\\
% 
To account for the race condition, when two objects take up the same voxel (\eg{} neighboring fiber segments) a distance map \code{distance array} is used.
In this 3d array the distance $d$ for a calculated orientation will be saved.
If a new point for another object has a smaller distance, it overwrites the orientation and distance.
Furthermore a 3d "label" array is needed, which represents the id of the physical properties which have to be used (\eg which layer or which fiber properties).
The value inside the label array corresponds to a look up table of a \code{property list}.
% 
The DV-Generator returns the \code{label field}, \code{vector field} and \code{property list}.
% 
\footnote{same calculations for cells, except that the birefingence and orientation is $0$.}
% 
\subsection{optimization}
% 
Two methods are used to parallel the algorithm on the \ac{CPU}.
The first uses \openmp for the parallelisation of filling the \ac{AABB} volume of each object.
The second uses \mpi to allow the distribution on multiple \ac{CPU} cores without the capability of shared memory. 
% 
The parallelisation of the \ac{AABB} volume leads to a race condition if multiple threads want to write in the same memory address (or coordinate) (\eg{} two objects occupy the same space).
A solution with a lock would be very slow.
Since the loop is over all $(i,j,k)$ indices of the three space dimensions, the parallelisation can be done over the indices.
However this leads to a slow implementation, since for every object new threads have to be spawned.
Therefore the parallel call is spawning all threads before the first loop over all objects.
Therefore all threads process all objects.
When the threads then loop over all indices, thread $n$ only processes the memory for the first volume dimension $i$ if:
% 
\begin{align}
\begin{split}
    i \bmod N_{\text{Threads}} == n
\end{split}
\end{align}
% 
This operation results in a thread safe writable operation.
The only disadvantage is, that all threads have to check, if the \ac{AABB} is inside the \ac{VOI}.
However since with this configuration only one time threads are spawned, it is rather quick.
One has to be known, that the array is in order $x-y-z$, therefore the largest memory displacement is in $x$ and the smallest in $z$.
This was chosen, so that later at the simulation process, where the light traverses usually mainly in $z$-direction, the memory is aligned with the needed information, and therefore the cache-prefetcher can be used.
% 
For large volumes bigger then the local shareable memory size the computation has to be split over multiple "nodes".
For this purpose \mpi{} is used.
Its slices the volume along the $x$-axis and $y-axis$ into blocks with a minimal surface area.
This is important for the next step (see \cref{sec:simulation}).
The data is know spit into different process and cannot be easyli be exchanged.
For the creation of the DV this is not necessary.
Each \mpi{} process can then create a discreticised sub volume as if it would be the hole volume.
However each sub volume has a additionally voxel along the $x$- and $y$-axis for later communication purpose (see \cref{sec:simulation}).
Each \mpi{} process can use \openmp{} to spawn multiple threads to efficiently use shared memory if the architecture supports it.
% 
% 
% 
\section{simulation}
\label{sec:simulation}
% 
\begin{figure}[!t]
\centering
\def\tikzwidth{0.42*\textwidth}
\inputtikz{gfx/simpli/vector_interpolation}
\caption{vector interpolation}
\label{fig:vectorfield_disc}
\end{figure}
% 
The simulation pipeline runs the M\"uller-Stokes calculus on the precious calculated discretised volume.
Since no scattering effects or refraction effects inside the tissue volume are included, each light ray trajectory follows a straight line.
The light matter interaction $\left( \prod_i R_i M_i R_i \times \vv{S} \right)$ is calculated. 
After the light ray reaches the end of the tissue the final optical elements (\eg{} polariser) are applied.
finally the light intensity is stored inside the resulting ccd-image array.\\
% 
The simulation allows a tiltable light beam.
The \ac{LAP} uses for this purpose a tiltible specimen.
The new designed microscop a tiltable light beam.
Both methods result in the same light path.
The tiltible specimen however results in a distorted view.
This distortion can be described by an affine transformation (see \cref{fig::affine_transformation}).
% 
\begin{figure}[!t]
\centering
\input{gfx/pli/affine_transformation}
\caption{affine transformation}
\label{fig::affine_transformation}
\end{figure}
% 
The simulation is able to calculate the distorted view (equivalent of the tiltible specimen) and the undistorted view (equivalent of the microscop. 
For the distorted view a so called "untilting" can be applied, which is a affine back transformation of the simulated image with linear interpolation (same as in the experiment).
% 
The simulation takes the effect of refraction of the tissue-air border into account.\footnote{glass adds only a parallel shift}
% 
To always get the same dens of light rays per ccd-pixel, all light ray starting positions are calculated from the ccd-pixels.
% 
\subsection{algorithm}
% 
\paragraph{calculation of light ray starting position}
% 
\begin{figure}[!t]
\def\tikzwidth{0.42\textwidth}
% \centering
% 
\subcaptionbox{normal}[.495\textwidth]{
\def\tilt{0}
\def\nindex{2.25}
\inputtikz{gfx/simpli/tilting_a}}
% 
\subcaptionbox{tilted}[.495\textwidth]{
\inputtikz{gfx/simpli/tilting_b}}
\caption{side view tilting}
\label{fig:tilted_side_view}
\end{figure}
% 
\begin{figure}[!t]
% 
\def\tikzheight{0.42\textwidth}
% \centering
\subcaptionbox{camera view}[.49\textwidth]{
\inputtikz{gfx/simpli/tilting_3d_a}}
% 
\subcaptionbox{perspective view}[.49\textwidth]{
\inputtikz{gfx/simpli/tilting_3d_b}}
% 
\tikzset{external/export=false}
\caption[3d tilting]{3d tilting: around $xy$-axis, \raisebox{.25em}{\tikz \draw[red,thick](0,0)--(0.25,0);} top, \raisebox{.25em}{\tikz \draw[green!50!black,thick](0,0)--(0.25,0);} middle, \raisebox{.25em}{\tikz \draw[blue,thick](0,0)--(0.25,0);} bottom, \raisebox{.25em}{\tikz \draw[dash pattern=on 1.25pt off 1.25pt,thick](0,0)--(0.25,0);} original, \raisebox{.25em}{\tikz \draw[gray](0,0)--(0.25,0);} axis of rotation \itodo{improve images}}
\end{figure}
% 
Snell's law describes the refraction of light between two different isotropic media:
\begin{align}
\begin{split}
    n_1 \sin{\Theta_1} = n_2 \sin{\Theta_2}
\end{split}
\label{equ:snell}
\end{align}
% 
The simulation uses as input parameter the refraction index of the tissue and the tilting angle to calculate the inner light angle.
From this the starting position of the light beam can be calculated (see \cref{fig:tilted_side_view}):
% 
First the light ray is backwords traversed starting at each ccd "pixel" (2).
Here the pixel size is equivalent to the voxel size.
Later the camera pixel size will be applied.
The light ray first hits the (tilted) tissue plane (2).
There its path is refrected according to Snells Law (\cref{equ:snell}).
From this the possition of the light at the bottom tissue plane (3) is calculated.
This is also the starting position of the light beam, since previous interactions do not require spatial information (\ie{} pol filter and $\lambda/4$-retarder).\\
% 
The ccd sensor and the tissue volume gets each their own coordinate system.
The ccd-sensor is described as a 2d plane.
The plane is rastered with a grid where each grid cell coresponds to a "pixel".
The light ray starts in the center of each "pixel", therefore a offset of $(\num{0.5}, \num{0.5})$ is added to the coordinate system for the geometric calculation.
The ccd-sensor index will be stored for each light ray in in case of a \mpi{} communication each process knows where to store the light intensity.\\
% 
The tissue coordinate system begins at the first array element with the index $(i=0, j=0, k=0)$.
The volume itself is specified by a dim-variable $(N_x, N_y, N_z)$.
Each voxel takes the space $[(i,j,k),(i+1,j+1,k+1))$ in space.
Therefore there is again a shift of \num{0.5} between the index and the center of each volume voxel.

% 
\paragraph{matrix calculus}
From the starting position the light tissue interaction will be calculated according to $\left( \prod_i R_i M_i R_i \times \vv{S} \right)$ (see \dummy{}).
Since the starting point is at the bottom of the tissue plain, and a light beam takes the step $s$ the physical property from $(x,y,z) + \frac{s}{2}$ is used (ZEICHNUNG).
For a non tilted view with a stept size equal to the voxel size this results in the indices values.
As long the light beam is inside the local (\mpi{}) tissue volume, everything can be calculated.
As soon as the light beam leaves the local volume it will be transfered to the appropriate mpi process.
If a linear interpolation of the properties is needed, the local volume gets in $x$ and $y$ direction an additional voxel.
With this "halo" the neighboring mpi process can also interpolate (with a distance of 1) the value.
Light which leaves the tissue / starts outside the tissue will be calculated with the background property.
% 
If the birefringence is 0 the multiplication of the M\"uller matrices is skipped and only the absorption is taken into account.
Since the M\"uller matrices are spasly (in this case), the calculation is optimized for this.
% 
\begin{lstfloat}[!t]
	\lstinputlisting[style=cpp,basicstyle=\scriptsize\ttfamily,]{code/simulation.cpp}
	\caption{Pseudocode simulation}
	\label{alg:simulation}
\end{lstfloat}
%
% 
\subsection{parallelisation}
There are several optimizations used inside this pipeline.\\
% 
First the order of the tissue stored inside the memory is along the z-axis.
This allows the light for the non tilted case along the z-axis and therfore along the memory.
therefore the data can be transferred linear to the cache and the prefetcher\footnote{A prefetcher get not only the data of the memory address i but also its neighbours i+1 and i-1 (depending on the order).
This means the data is already in cache, if the next step is calculated.
For linear traversions this means effectively a infinitive cache size.} of (modern) \ac{CPU} architectures hits its full potential.
This is also noticeable in the tilted view, since the tilting angle in the \ac{3D-PLI}-experiment is rather small.
This reduces secnificantly the acces time of the \ac{CPU} and the \ac{RAM}.\\
% 
Secondly the main for loop for each light ray is parallized with \openmp{}.
This threads are completely separated and no race conditions exists.\\
% 
Additionally the same mpi topography is used from the DV-Generator (see \cref{sec:dv_generator}).
This is the reason the volume gets split into smaller parts with minimal surface area, since then the number of needed communications is also minimal.
In the previous \simpli{} implementatio the communication was not needed because the halo was as big that the light beam was never leaving the local volume.
This however meant, that for each tilted image the local volume had to be recalculated.
Also the memory consumption was much larger.
This yields in a quite big reduction of processing time. \footnote{so much, that the local memory is the bootlenek, not the cpu power.}\\
% 
At corners the light beam can travel through several \mpi{} volumes.
Therefore after each main loop the ommunication has to be done.
Then the main loop is repeated with all incomming light rays.
When no light rays are communicated anymore, the simulation is finished.
This is a rather small cost considering the saving of memory and for tissue section commenly thin tissue sections of \SI{60}{\micro\meter}.
% 
% 
% \lstinputlisting[language=c++, name=mpi_comm, caption={MPI code simulation}, label={alg:mpi_comm}]{code/mpi_comm.cpp}
% \begin{lstfloat}[!h]
% 	\caption{Pseudocode simulation}
% 	\label{alg:mpi_comm}
% \end{lstfloat}
% 
\todo{smart sampling}
