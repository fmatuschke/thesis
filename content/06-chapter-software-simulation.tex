\setcounter{chapter}{4}
\chapter{\acs{3D-PLI} simulation}
\label{cha:sof:simulation}
% 
% Interesse wecken: warum braucht man es, warum ist es kompliziert, lÃ¶sbare probleme
% 
% 
% \textcolor{gray}{
% Simulation are a technique which are getting more commonly used in this century.
% In literature it is knows as \name{in silico} meaning \say{performed on computer} where silicon stands for the silicon in computer chips.
% It is a analogy to \name{in vivo} (within the living), \name{in vitro} (in the glass) and \name{in sito} (on site), which are commonly used in biology and medicine.
% Simulations can be a cheaper and faster approach to doing experiments.
% However since the knowlege increases over time, the experiments and simulations bekome more and more compilacted.
% For simulations this usually means, more precise calculations and more effects have to be considered when doing predictions of the real world.
% If no mathematical shortcuts are developed or even exists this leads to more calculation intense and time consuming procedures.
% In the past Moores Law was a good thriver to be able to do more expensive calculations.
% However currently the computer chips are physically at there limit with a few nanometer at scale (at least in 2d).
% Also the clock frequency is almost at its limits since at that scale the \say{wires} inside the chips become more conductive because they behave as a capacitor.
% Additionally quantum effects like tunneling become another barrier since they introduce error currents.
% \\
% % 
% Since about one decade \acs{GPU} become more and more commonly used in simulations and other algorithms.
% They have the advantage of calculate a lot of parallel instructions at the same time.
% However they come with the cost of being (at least for now) slower than a \ac{CPU}.
% \\
% % 
% Further then that only super computers can help to solve the high demand on computer power needed.
% }
% \par
% 
% 
In the past simulation of \ac{3D-PLI} already shown their capabilities \cite{Dohmen2015,Menzel2015,Menzel2016,Menzel2020,Menzel2021,MenzelMaster,MenzelDissertation}.
In the case of scattering finite-difference time-domain simulations the here presented algorithm to design new collision free fiber models allowed for the first time to simulate the effect of scattering light without any superposed interference signals.
This allowed the understanding of scattering effects due to the configurations of fiber bundles and crossings as well as the transmittance change for inclined fiber configurations.\cite{MenzelDissertation,Menzel2020,Menzel2021}.
%  
In the case of the simulation of linear optics the optical system could repoduse the experimental results with \eg{} the optical resampling process \cite{Dohmen2015,Menzel2016}.
However this algorithm is very computational heavy and due to the precalculations of a discretised tissue volume, very memory intense.
The foundations of a more efficient parallel algorithm for the use of supercomputer was already elaborated \cite{Lucksch2016}.
However, the new tilting design resulted in a simplification of the former simulation that could not be easily integrated.
Therefore the algorithm was completely redesigned and rewritten.
Additionally the here presented fiber models had to be Incorporated as well.
Finally the descision was made, to switch to the M\"uller Stokes calculus to allow the \dummy{} of filter \dummy{}.
% 
\par
% 
The Simulation is split into two consecutive parts: the volume discretizer and the simulation.
The volume discretizer discretises the virtual nerve fiber models onto a cartesian grid, which is then in the second step used to calculate the light matter interaction.
One parallelization technique allows to split the volume onto different \acp{CPU} or nodes.
Due to the tilting approach, the light vector needed to be able to leave the current volume of a single \ac{CPU} and traverse to the next volume/\ac{CPU}.
This simulation as well as the optical \dummy{} of the system and the tilting analysis will be \dummy{} here.
\\
% 
The code is as the former written in \cpp{} with a user friendly wrapper function in \python{}.
% 
\dummy[wohin mit den zukunftsplaenen? -> ende]{}.
% 
% 
% The here presented \fastpli{} software package allows to predict \ac{3D-PLI} experiments within the \python package \pymodule{fastpli.simulation} by means of linear optics \cite{} and 3d fiber models \cite{}.
% It is based on the previous develop tool \simpli{} \cite{Dohmen2015}, which was then further developed and already parallel for the use on the super computers by multiple \acp{CPU} \cite{Lucksch2016}.
% This version however uses M\"uller matrices \cite{} to define the optical elements and the Stokes vector \cite{} for describing the light \cref{sec:Mueller-Stokes}.
% %
% The further development of the algorithm will be described in the following.
% \par
% % 
% The following procedures are described in this chapter:
% \begin{itemize}[nosep]
%     % \item overview
%     \item model discretization technique
%     \item simulation
%     \item optic imitation 
%     \item analysis
%     \item optimization
% \end{itemize}
% % 
% The computational heavy calculations of the discretization and simulation part are written in \cpp{} which are wrapped inside a \python{} class \code{simpli} for user friendly interactions.
% The additional algorithms of the optic are written in \python{}.
% % 
% \par
% % 
% The \ac{3D-PLI} Simulation is in its \ac{CPU} version\footnote{At the end of the dissertation Alexander Kobush developed a GPUsimPLI approach under my supervision \cite{}.} split into two parts.
% The first part called \name{Generation} \todo{name} generates a discretizied 3d volume of the nerve fiber models from \cref{chap:modelling}.
% This means that all properties \eg{} optical axis are saved in a 3d array.
% This \say{volume} is then later be used to perform the light matter interaction by means of linear optic described in \cref{sec:theory}.
% Last but not least the light interaction with the \ac{CCD}-Sensor will be performed inside the \pymodule{fastpli.simulation.optic} module.
% The resulting data correspond the a \ac{3D-PLI} row data image.
% Further analysis algorithms are implemented
% With these the same type of analysis as in the \ac{3D-PLI} experimental analysis can be achieved.
% All Algorithms are combined inside a \python{} class called \pymodule{fastpli.simulation.simpli}.
% Inside is everything to perform a pipeline code as well as full control about every step inside the pipeline.\todo{veroffentlichung in intro}
% 
\section{DV-Generator}
\label{sec:dv_generator}
% 
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.5\textwidth}
\inputtikz[true]{gfx/simpli/disc_volume}
\caption[discreticed tissue volume]{discretized tissue volume: Its \dummy{} is defined by a \ac{AABB}, which is defined by two variables. \itodo{show x,y,z resulting volume?}\itodo{show fiber model inside?}}
\label{fig:discVol}
\end{figure}
% 
\itodo{better name}
% 
The idea of the simulation is to first calculate a so called \say{discretised tissue volume}.
It represents a discrete constant voxel model of the tissue.
This helps to drastically speed up the light matter interaction of the next step (see \cref{sec:simulation}).
\par
% 
The discreticed tissue volume represents a cuboid sliced into equal sized smaller cubes called voxels, \ie 3d pixels (see \cref{fig:discVol}).
Each voxel contains the physical properties of the tissue inside its current position.
The overall volume is limited by an \ac{AABB} or \ac{VOI}, which is defined by a minimal and maximal value $\voi = [(x_{\mathit{min}}, y_{\mathit{min}}, z_{\mathit{min}}),(x_{\mathit{max}}, y_{\mathit{max}}, z_{\mathit{max}})]$.
Additionally the \voxelsize{} parameter \voxels{} is set to a floating point number and defines the edge length of the voxels.
If the division of the \voi{} by the \voxelsize{} is not an integer, the \voi{} is automatically increased to the next possible integer value to avoid boundary effects.
% 
% 
% 
\subsection{Nerve fiber layers}
% 
As described in \dummy{} nerve fibers are axons, which can be wrapped around by several windings of myelin (see \cref{fig:fiberLayer}).
Especially for light wave simulations the myelin windings are a significant property \cite{MenzelDissertation}.
This makes it necessary to be able to build such a structure.
\par
% 
An easy implementation is to represent the windings as layers (see \cref{fig:myelinLayer}).
This simplifies the creation process significantly.
A layer can then simply defined by a factor between $0$ and $1$, which scales with the nerve fiber radius.
For example, $0.75$ means that from $0 \leq r < 0.75$ of the radii are interpreted as the first layer.
\par
% 
Each layer needs to its radius also a set of physical properties:
% 
\begin{itemize}[nosep]
    \item birefringence value $\dn$
    \item absorption coefficient $\mu$
    \item optical axsis model $p=\mathit{parallel}$, $r=\mathit{radial}$, $b=\mathit{background}$
\end{itemize}
% 
These properties are set as a list of tuples inside the algorithm (see \cref{alg:fiberbundleprops}).
% 
\begin{lstfloat}[!ht]
\lstset{style=python}
\begin{lstlisting}[]
fbs_properties = [[(r, dn, mu, 'p'), (second layer), ...],
                  [(first layer of second bundle), ...],
                  [...]]
\end{lstlisting}
\caption[Fiber bundle properties]{Defining fiber bundle properties.}
\label{alg:fiberbundleprops}
\end{lstfloat}
% 
At the end the DV-Generator returns the arrays \tissue{}, \opticalaxis{} and the \propertylist{} for the use of the simulation.
% 
\subsection{Discretizing a nerve fiber model}
% 
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.32\textwidth}
\subcaptionbox{\label{fig:myelinLayer}Schematic of nerve fiber with axon and wrapped around myelin}[.32\textwidth]{
\includegraphics[height=0.3\textwidth]{dev/brain/myelin_layers.pdf}\vspace{0mm}}\hfill
\subcaptionbox{\label{fig:fiberLayer}Cross section nerve fiber with layered structure definde by $n$ radii}[.32\textwidth]{
\inputtikz[true]{gfx/simpli/fiber_layer}\vspace{-5mm}}\hfill
\subcaptionbox{\label{fig:vectormodel}Cross section of discreticed nerve fiber with resulting vectors of optical axis}[.32\textwidth]{
\inputtikz[true]{gfx/simpli/vector_model}\vspace{-5mm}}
\caption{Discretisation of nerve fiber with layered structure.}
\label{fig:fiber_discretisation}
\end{figure}
% 
To discretize nerve fiber models (see \cref{chap:sof:modelling}) one can start with the discretization of a single nerve fiber segment, since a fiber is a chain of consecutive segment.
The idea is, that if a voxel is inside a fiber segment, it will be marked as a tissue with the physical properties (absorption, optical axis and birefringece) from the voxels center position $\vec{q}$ (see \cref{fig:fiber_discretisation}).
In this context \say{a voxel inside a fiber segment} means, that its center point is inside the volume of the fiber segment.
The discretized tissue is designed in such a way that, that the arrays position $[i,j,k]$ takes up the space of $(i,j,k)$ to $(i+1,j+1,k+1)$ in the unit of \voxelsize{}.
\par
% 
Therefore the filling process can be integrated by looping over all voxels in the current volume.
However since a single nerve fiber segment is usually much smaller than the volume, it makes sense to reduce the size of the iterating voxels.
This is easily be done by only iterating over the voxels of the \ac{AABB} of the nerve fiber segment.
\par
% 
Now each voxel will be checked, if it is inside the nerve fiber segment.
This is analog calculated to the collision between two nerve fiber segment (see \cref{alg:pseudocodeCollisionDetection}) except that only one point of the closest distance has to be found.
The other one is the voxels center position $\vec{q}$.
From this calculation the not only the closes point \dummy{} will be returned, but also the distance vector \dummy{}. 
This helps to calculate the the distance, which will be used to check if the voxel is inside the fiber segment, and if it is, in wich layer of the fiber segment it is.
Additionally the distance vector can be used, if the optical axis inside the current layer is set to a microscopic \dummy{}, which means that the optical axis is orientated radial to the fiber segment.
\par
% 
Two values have to be stored in the case of a valid entry.
The first one is an index inside a \code{tissue} array, which is later used to retreve the properties from a list with the same index order.
The second one is the orientation of the optical axis inside the current layer.
The orientation is either parallel to the fiber segment in case of the macroscopic model, or radial in the case of the microscopic model.
A layer can also be marked as \say{background}, which will allow the user to specify a region with absorption, but without a birefringence.
\par
% 
Before looping over all fiber segments, an additional problem has to be solved.
Since two consecutive fiber segments will take up the same space because they share a point, they also will fill the voxel of the tissue volume.
This is a problem, since now the second fiber segment will overwrite the values of the first one.
This can easily be solved by adding an additional array, which will store the smallest distance inside, which was calculated when filling the voxels space.
The values will now be overwritten, if a new smallest distance was calculated, which is smaller then the already stored one.
This also solves the problem, that at the end end points of a fiber segment in the case of a radial optical axis model, the optical axis would be \say{star like}.
This of course will still be the same at the beginning and end of an fiber.
\par
% 
This \say{filling} loop is represented in the pseudocode \cref{alg:fillVolume}.
% 
\begin{lstfloat}[!tb]
\lstset{style=python}
\begin{lstlisting}[]
for fiber_segment in fiber_bundle:
    for i,j,k in fiber_segment.aabb().voxels():
        min_dist, min_point = calculate_min_distance((i,j,k), cc)
        if min_dist < cc.radius:
            if min_dist < current_distance[i,j,k]:
                optical_axis[i,j,k,:] = get_axis_orientation(
                                            (i,j,k), min_dist,
                                            min_point)
                tissue[i,j,k] = get_layer_id(min_dist)
                current_distance[i,j,k] = min_dist
\end{lstlisting}
\caption{Discretized volume filling algorithm}
\label{alg:fillVolume}
\end{lstfloat}
%
\itodo{the length of the stored optical axis vector is interpreted as strength. In this model the length is always 1. If the user wishes to add variability, he/she can do this by changing the length of the vectors inside the arrays.}
% 
% 
% 
\subsection{\voxelsize}
% 
\begin{figure}[!t]
\centering
% \tikzset{external/export=false}
\setlength{\tikzwidth}{.24\textwidth}
\input{gfx/simpli/vector_error}
\caption[Discretization error]{Discretization error. Cross section of single fiber with one myelin layer inside discretized tissue volume. The couloured pattern show the resulting voxels which corresponds to the fiber. The smaller the \voxelsize{}, the smaller the representation error.}
\label{fig:vectorfield_disc_error}
\end{figure}
% 
The \voxelsize{} parameter is the most important property of the simulation.
It will determine, how accurate the simulation is \dummy{}. 
This is first of all because it will change the number of voxels with which the nerve fiber model is discretized (see \cref{fig:vectorfield_disc_error}).
Especially for the case of multiple layers this will have an major impact.
Additionally it will also change the \stepsize{} of the light through the tissue.
Usually the \stepsize{} is the same as the \voxelsize{}, but the user can change it if necessary.
Also the number of light particels will increase with decreasing \voxelsize{} since for about each voxel at the bottom of the tissue a single light particle will be casted (see \cref{sec:pathOfLight}).
Therefore the resulting intensity signal will also be more accurate.
% 
% 
%  
\subsection{optimization}\label{sec:dvOpti}
% 
All arrays are implemented as contiguous c-arrays, which are accessible as \name{Numpy}-arrays from outside without the need to copy the data.
Since these arrays grow with $\mathcal{O}(n^3)$, the aim was to make them movable through the \cpp{} libraries as well as in \python{}.
The memory order of the arrays is in $x\text{-}y\text{-}z$ direction, so the largest memory shift is in $x$ and the smallest in $z$.
This was chosen so that later in the simulation part, where the light travels mainly in $z$-direction, the memory is aligned to the required information and thus the \acp{CPU} cache prefetcher can be used.
\par
% 
Two methods are used to parallelize the algorithm on the \ac{CPU}.
The first uses \openmp{} to parallelize the filling of the \ac{AABB} volume of each object.
The second uses \mpi{} to allow distribution to multiple \ac{CPU} cores without sharing memory (detailed description in \cref{sec:mpiSim}).
\par
% 
The parallelization of filling the voxels of the discretized volume leads to a race condition if several threads want to write or read to the same memory address (or coordinate) (\eg{} two objects occupy the same space).
A solution with a lock would be very slow since, depending on the fiber segment length and orientation, most voxels of the \ac{AABB} have to be written to.
Also since many of the voxels don't need to be overwritten, most locks would be unnecessary.
\\
Since the loop runs over all $(i,j,k)$ indices of the three space dimensions, the parallelization can be done using the iteration over the voxels themself per fiber segment.
However, this leads to a slow implementation because new threads have to be spawn for each fiber segment, which takes quite some time.
If was therefore decided, that the parallel call creates all threads before the first loop over all objects.
This means all threads process all objects.
If the threads then execute a loop over all indices (or coordinates), thread $n$ only processes the memory for the first volume dimension $i$ if (see \cref{fig:discVolThread}):
% 
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.5\textwidth}
\inputtikz{gfx/simpli/disc_volume_thread}
\caption[discretized volume parallelization]{discretisation volume parallelization with \openmp{}. Each thread handles every n-th yz-section. This ensures both thread safety and that the workload is more balanced, even with an inhomogeneous.}
\label{fig:discVolThread}
\end{figure}
% 
\begin{align}
\begin{split}
    i \bmod N_{\mathit{Threads}} == \mathit{thread}_{\mathit{id}}
\end{split}
\end{align}
% 
This process results in a thread-safe writable operation.
The only drawback is that all threads must check if the \ac{AABB} is inside the \ac{VOI}.
However since with this configuration only once threads are spawned, and the \ac{AABB} collison check is very efficient in terms of computation time, it is quite fast.
Additionally the shared cache of the \acp{CPU} can speed up the memory retrieving process as well, if the \acp{CPU} workload do not differ that much.
\par
\paragraph{Note}
Depending on the scice of the volume and the acessable memory, the user is adviced to distribute the \openmp{} parallelization and \mpi{} distribution \dummy{}.
The \openmp{} speedup is usually as fastest if the spawend threads are located on the same physical \ac{CPU} or even inside the same \acp{CPU} which uses the same cache.
It can therefore be that the speedup is increased by reducing the \openmp{} threads and by increasing the \mpi{} threads instead \todo{better mpi implementation?}.
% 
% 
% 
\section{Simulation}
\label{sec:simulation}
% 
The simulation algorithm executes the M\"uller-Stokes calculus (see \cref{sec:Mueller-Stokes}) on the previously calculated discrete volume (see \cref{sec:dv_generator}) for a light beam along its path.
Since no scattering or refraction effects are included in this simulation, each light path follows a straight line.
The interaction of light matter is calculated according to $\left( \prod_i R_i M_i R_i \cdot \vec{S} \right)$ (see \cref{sec:mueller_stokes}). 
Befor the light vector is multiplied by the polarizer of the optical system.
After the light beam has reached the end of the tissue, the last optical elements are taken into account.
Finally, the light intensity is stored in the \acs{CCD} image array, which has at this point the same size as the 2d $xy$-grid of the discretized tissue.
At the end it will be resampled to the final \ac{CCD} array size and a noise model will be applied.
% 
%
\subsection{Path of light}
\label{sec:pathOfLight}
% 
\begin{figure}[!t]
\setlength{\tikzheight}{0.42\textwidth}
\subcaptionbox{camera view}[.49\textwidth]{
\inputtikz{gfx/simpli/tilting_3d_a}}\hfill
\subcaptionbox{perspective view}[.49\textwidth]{
\inputtikz{gfx/simpli/tilting_3d_b}}
\tikzset{external/export=false}
\caption[3d tilting]{3d tilting: around $xy$-axis, \raisebox{.25em}{\tikz \draw[red,thick](0,0)--(0.25,0);} top, \raisebox{.25em}{\tikz \draw[green,thick](0,0)--(0.25,0);} middle, \raisebox{.25em}{\tikz \draw[blue,thick](0,0)--(0.25,0);} bottom, \raisebox{.25em}{\tikz \draw[dash pattern=on 1.25pt off 1.25pt,thick](0,0)--(0.25,0);} original, \raisebox{.25em}{\tikz \draw[gray](0,0)--(0.25,0);} axis of rotation \itodo{test david und daniel}}
\label{fig:tilting_camera_view}
\end{figure}
% 
The simulation allows a tiltable light beam.
For this purpose, the \ac{LAP} uses a tilting stage to which the tissue sections are attached (see \cref{fig:tilted_side_view}). 
The newly designed microscope on the other hand has a already tilted light beams.
There are generated by an conical light path, from which then with an aperture the desired light orientation is sampled (see \cite{Wiese:887678}).
Both methods yield within a good approximation to the same light paths.
\\
% 
The tilting can lead to a distortion of the image (see \cref{fig:tilting_camera_view}).
This distortion can be described by an affine transformation (see \cref{fig::affine_transformation}):
% 
\begin{figure}[!t]
\centering
\input{gfx/pli/affine_transformation}
\caption{affine transformation}
\label{fig::affine_transformation}
\end{figure}
% 
\begin{align}
f(\vec{x}) = \mat{A} \cdot \vec{x} + \vec{t}
\end{align}
where $\vec{x}$ the coordinate input, $\mat{A}$ and $\vec{t}$ the transformation values and $f(\vec{x}$ the transformed coordinate.
\\
% 
The simulation is able to take the distorted view into account and it can resample the starting positions of the light beams such, that the distortion is reversed.
It is the same as distorting the \ac{CCD} sensor, however without the need of interpolation of the \ac{CCD} image sensor.
In the case of simulating the distortion, the affine inverse transformation $f^{-1}(\vec{x}) = \mat{A}^{-1} \cdot \vec{x} - \vec{t}$ can be applied.
However, this leads to interpolation artifacts.
Therefore both techniques exists to be able to study this effect in more detail.
\par
% 
An additional effect is the simulation of the refraction of the tissue-air border, which is described by Snell's law for isotropic media (see \dummy{})
Since this only adds a parallel shift, a simulation is only necessary if the resampling of an image registration is to be studied.
\par
% 
\begin{figure}[!t]
\setlength{\tikzwidth}{0.42\textwidth}
\subcaptionbox{normal}[.495\textwidth]{
\def\tilt{0}
\def\nindex{2.25}
\inputtikz[true]{gfx/simpli/tilting_a}}\hfill
\subcaptionbox{tilted}[.495\textwidth]{
\inputtikz[true]{gfx/simpli/tilting_b}}
\caption[Light path]{Ligh path for a normal a) and tilted b) case. For the tilted case the light beam $I1$ \dummy{check} gets tilted inside the tissue and therefore recieves a optical shift $\Delta$.}
\label{fig:tilted_side_view}
\end{figure}
% 
The starting position of the light beam can be calculating by traversing the light path backwards (see \cref{fig:tilted_side_view}).
Each light beam $\vec{l}_0$ hitting the \ac{CCD}-array element, not resampled yet to the actual \ac{CCD} pixel size, can be traversed back to the tissue top plane $\mathfrak{S}_{top}$.
Next the light beam $\vec{l}_1$ is traversed back through the tissue to the bottom plane $\mathfrak{S}_{bottom}$.
The point on the bottom tissue plane corresponds to the starting position of the light beam.
In the case of a tilted light beam or lilted tissue, a offset of $\Delta$ is occurs.
\todo{The backtracking of the light from the ccd array is better so that in the resampling process no boarder effects can occurs}
\\
% 
In the case of already simulating an undistored view, the light paths have to spaced out by the same distance, as the affine transformation would resample the resulting pixels.
% 
\begin{lstfloat}[!p]
	\lstinputlisting[style=cpp,basicstyle=\scriptsize\ttfamily,]{code/simulation.cpp}
	\caption{Pseudocode simulation \itodo{anhang}}
	\label{alg:simulation}
\end{lstfloat}
% 
\subsection{Tissue voxel interpolation}
% 
For a \stepsize{} unequal to the \voxelsize{} or a tilted light path the midpoint does not match the center point of the voxel anymore.
This means, that the physical properties stored in the arrays have to be interpolated.
% 
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.45\textwidth}
% \tikzset{external/force remake=true}
\subcaptionbox{\label{fig:triInterp}Trilinear interpolation}[\tikzwidth]{
\hfill\inputtikz{gfx/simpli/trilinear_interpolation}\hfill}\hfill
\subcaptionbox{\label{fig:vectormodel}Spherical interpolation}[\tikzwidth]{
\inputtikz{gfx/simpli/vector_interpolation}}
\caption[]{Interpolation techniques: The trilinear interpolation can be visualized as a axial step interpolation. The difference between linear and spherical interpolation is that the linear interpolation has a constant distance $s$ between each point while the spherical interpolation has a constant angle $\varphi$ for the same step.}
\label{fig:vectorfield_disc}
\end{figure}
% 
There are currently three interpolation methods for this purpose implemented: \textit{nearest neighbor}, \textit{linear interpolation} and \textit{spherical interpolation}. 
The voxels taken into account for the interpolation are the nearest 8 adjacent voxels, so array indices $(\floor{x\pm0.5},\floor{y\pm0.5},\floor{y\pm0.5})$.
% 
The \textit{nearest neighbor} is the most error-prone of the three methods and should be not to be used. 
However it is also the fastest method.
The \textit{linear interpolation} was the first one implemented.
However since the data contain orientation data, the \textit{spherical interpolation} method should be used.
\\
% 
To interpolate the data the trilinear interpolation will be performed (see \cref{fig:triInterp}).
% 
% 
% 
\subsection{algorithm}
% 
First the starting points of all light beams will be calculated.
hen each light beam can be traversed inside the tissue.
To calculate the light matter interaction, the \dummy{} will be calculated after each light beam step.
As soon as the light hits the boarder of the tissue, the light beam will be the last optical elements and the intensity will be stored inside the \ac{CCD} array.
The pseudocode is shown in \cref{alg:simulationLoop}.
% 
\begin{lstfloat}[!tb]
\lstset{style=python}
\begin{lstlisting}[]
light_beams = calculate_light_starting_positions()

for light in light_beams:
    light = optical_elemts_start * light
    while light.pos in volume:
        properties = get_properties(light.pos)
        light.intensity *= exp(-step_size * properties.absorbtion)
        light = matrix(properties) * light
        light.pos += step_size
    
    light = optical_elemts_end * light
    ccd_array[light.ccd_pos] = light.intensity
\end{lstlisting}
\caption{Discretized volume filling algorithm}
\label{alg:simulationLoop}
\end{lstfloat}
% 
% 
% 
\subsection{Optimizations}
% 
There are several optimizations used inside this pipeline. 
First the order of the tissue stored inside the memory is along the z-axis (as described in \cref{sec:dvOpti}). 
Secondly the main for loop for each light ray is parallized with \openmp{}.
This threads are completely separated and no race conditions exists.
% 
% 
% 
\subsection{Optic}
\label{sec:ccdOptic}
% 
The image sensor as described in \cref{sec:expSetup} is a \ac{CCD} sensor.
The calculations, \ie resolution \dummy{}, resampling and noise modelling, are implemented according to \cref{sec:opticalResolution}.
These calculations are performed on the python side of the algorithm and can be parallized with the \code{multiprocessing} library of \python{}.
% 
% A general \ac{CCD} sensor consits out of an array of capacitors.
% In each capacitor an electric charge will be stored, setted free by an incoming photons.
% After a read out process, which also contains a electric gain, the resulting values can be stored as an image.
% This process has two major noise parts. The first is the electic charge.
% Its value is, as long as it is not saturated, linear correlated with the number of photons.
% However internal noise like thermal, and a each photon statistically charges a number of electrons, the resulting capacity varies.
% The second major noise comes from the gain process.
% Here the electric voltage will be gained before a analog digital read out.
% This process is also strong linear correlated around a operational point.
% However due to the nature of the underlining circuit, i.e. usually transistors and their power source, the resulting value can vary.
% All noise sources combined yield to an poison distributed noise, to too the nature of digital values.
%
% \\
%
% To account for the optical setup, three things have to be done.
% \paragraph{Bluring}
% The optical resolution the light rays have to be blurred.
% This is classically done via a 2d gaussian convolution:

% \paragraph{Sampling}
% Since the number and final position of the light rays is according to the voxels, all intensities of an image pixel have to be combined.
% Here it is done via a mean value sampling.
% This in contrast to resizing, does not interpolates the image.
% % 
% \paragraph{Noise}
% The last step is to replicate the noise of the image setup. To account for this a noise model has to be applied to each image pixel. \cite{Wiese:887678} showed that this can be done via a poisson/gaus model.
% 
% 
% 
\section{Analysis}
% 
The same algorithms are implemented as in the \ac{3D-PLI} routine pipeline \dummy[-> theory]{}.
This include the modalities analysis transmittance, direction and retardatation as well as the tilting analysis performend by \ac{ROFL}.
% 
% 
% 
\section{MPI parallelization}\label{sec:mpiSim}
% 
Both algorithms, the DV generator and the simulation can use an additionally parallelization technique.
% 
For huge volumes that are larger than the locally memory size, the calculation must be split onto several physical \acp{CPU} and \name{computation nodes}\footnote{A computing node is a processing unit in a computer network}.
For this purpose \acreset{MPI} \ac{MPI} is used.
A method is implemented that automatically divides the volume along the $x$-axis and $y$-axis into blocks with minimal surface area (see \cref{fig:com_halo}).
The minimization of the $x-y$-surface area is important for the simulation algorithm.
\\
Once the volume is split into euqal parts, with respect to the nature of integers, the above mentioned algorithms can be performend completly analog on the \mpi{} ranks, as if they only would know about there volume.
The only exception is the simulation for tilted light beams.
This means, that at the boarder of the volume, when a light beam travels through the tissue, the light can leave the local volume of the \mpi{} rank.
\mpi{} provides several methods to send information to another rank.
Since this volume splitting is cartesion, the cartesion implementations of \mpi{} are used (\eg{} \code{MPI\tu Cart\tu create}).
However since the light beam also needs in the case of interpolation the information of the surrounding $\SI{8}{\voxel}$, this would mean that the missing voxels had to be transferred to the neighboring ranks.
% 
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.75\textwidth}
\inputtikz{gfx/simpli/com_halo}
\caption{comunication halos. The volume is split into six subvolumes, distributed to 6 mpi ranks. The coloured voxels have the same tissue information.  To calculate the value at a given point a eight-neighborhood is necessary.}
\label{fig:com_halo}
\end{figure}
% 
This would mean a huge amount of communications, which are relatively slow.
The solution is a so called \name{halo}.
This is a commonly used concept, where the borders (in this case a volume) are enlarged by a a specific size (in this case $\SI{1}{\voxel}$) so that the same information of the shared regions is available everywhere (see \cref{fig:com_halo}).
% 
% \begin{figure}[!t]
% \centering
% \def\tikzwidth{0.5\textwidth}
% \inputtikz[]{gfx/simpli/com_halo_send}
% \caption{Light ray send to another node. To calculate the \dummy{} a eight-neighborhood is necessary.}
% \label{fig:com_halo_light}
% \end{figure}
Now the light beam can be communicated when it leaves the local volume to the next one (see \cref{fig:com_halo}).
This is also the reason, why the surface area is minimized, so that the number of communications is also minimized.
\\
To even more speed up the communication process, all leaving light beams are first stored locally in a communication buffer, and only after all local light beams were processed, the buffer will be communicated to the neighbors.
This ensure a minimal communication cost.
The main light beam algorithm loop is then started again on all \mpi{} ranks for the communicated light beams.
This is repeated until no more communications were necessary.
\par
% 
Each \mpi{} process can additionally use \openmp{} to create multiple threads for efficient use of shared memory if the architecture supports it.
% 