\setcounter{chapter}{5}
\chapter{\acs{3D-PLI} Simulation}
\label{cha:simulation}
% 
Simulation are a technique which are getting more commonly used in this century.
In literature it is knows as \name{in silico} meaning \say{performed on computer} where silicon stands for the silicon in computer chips.
It is a analogy to \name{in vivo} (within the living), \name{in vitro} (in the glass) and \name{in sito} (on site), which are commonly used in biology and medicine.
Simulations can be a cheaper and faster approach to doing experiments.
However since the knowlege increases over time, the experiments and simulations bekome more and more compilacted.
For simulations this usually means, more precise calculations and more effects have to be considered when doing predictions of the real world.
If no mathematical shortcuts are developed or even exists this leads to more calculation intense and time consuming procedures.
In the past Moores Law was a good thriver to be able to do more expensive calculations.
However currently the computer chips are physically at there limit with a few nanometer at scale (at least in 2d).
Also the clock frequency is almost at its limits since at that scale the \say{wires} inside the chips become more conductive because they behave as a capacitor.
Additionally quantum effects like tunneling become another barrier since they introduce error currents.
\\
% 
Since about one decade \acs{GPU} become more and more commonly used in simulations and other algorithms.
They have the advantage of calculate a lot of parallel instructions at the same time.
However they come with the cost of being (at least for now) slower than a \ac{CPU}.
\\
% 
Further then that only super computers can help to solve the high demand on computer power needed.
\\[\baselineskip]
% 
The here presented \fastpli{} software package allows to predict \ac{3D-PLI} experiments within the \python package \pymodule{fastpli.simulation} by means of linear optics \cite{} and 3d fiber models \cite{}.
It is based on the previous develop tool \simpli{} \cite{Dohmen2015}, which was then further developed and already parallel for the use on the super computers by multiple \acp{CPU} by Sonja Lucksch \cite{Lucksch2016}.
This version however uses M\"uller matrices \cite{} to define the optical elements and the Stokes vector \cite{} for describing the light \cref{sec:Mueller-Stokes}.
%
The further development of the algorithm will be described in the following.
\\[\baselineskip]
% 
The following procedures are described in this chapter:
\begin{itemize}[nosep]
    % \item overview
    \item model discretization technique
    \item simulation
    \item optic imitation 
    \item analysis
    \item optimization
\end{itemize}
% 
The computational heavy calculations of the discretization and simulation part are written in \cpp{} which are wrapped inside a \python class \code{simpli} for user friendly interactions.
The additional algorithms of the optic are written in \python 3.
% 
\\[\baselineskip]
% 
The \ac{3D-PLI} Simulation is in its \ac{CPU} version\footnote{At the end of the dissertation Alexander Kobush developed a GPUsimPLI approach under my supervision \cite{}.} split into two parts.
The first part called \name{Generation} \todo{name} generates a discretizied 3d volume of the nerve fiber models from \cref{chap:modelling}.
This means that all properties \eg{} optical axis are saved in a 3d array.
This \say{volume} is then later be used to perform the light matter interaction by means of linear optic described in \cref{sec:theory}.
Last but not least the light interaction with the \ac{CCD}-Sensor will be performed inside the \pymodule{fastpli.simulation.optic} module.
The resulting data correspond the a \ac{3D-PLI} row data image.
Further analysis algorithms are implemented
With these the same type of analysis as in the \ac{3D-PLI} experimental analysis can be achieved.
All Algorithms are combined inside a \python{} class called \pymodule{fastpli.simulation.simpli}.
Inside is everything to perform a pipeline code as well as full control about every step inside the pipeline.
% 
\section{DV-Generator}
\label{sec:dv_generator}
% 
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.5\textwidth}
\inputtikz{gfx/simpli/disc_volume}
\caption{discretisation volume}
\label{fig:discVol}
\end{figure}
% 
First, the volume to be created must be defined.
The simulated/discretized volume is limited by an \ac{AABB} or \ac{VOI}, which is defined by a minimal and maximal value $\voi = [(x_{\mathit{min}}, y_{\mathit{min}}, z_{\mathit{min}}),(x_{\mathit{max}}, y_{\mathit{max}}, z_{\mathit{max}})]$.
Additionally the \voxelsize{} parameter is set to a floating point number and defines the edge length of the discretized voxels.
If the division of the \voi{} by the \voxelsize{} is not an integer, the \voi{} is automatically increased to the next possible integer value.
\\
% 
There are two arrays with information about the discrete volume.
First the \tissue array.
It contains an index value to the corresponding list of physical properties (see \cref{alg:fiberbundleprops}). \todo{has immense potential for zipping.}
Second, the \opticalaxis-array.
It contains sliding values of the $x,y,z$ values of the optical axis orientation (see \cref{fig:vectormodel}).
Additionally, there will be a \code{distance} array for the generation algorithm, which contains information about how far away the next currently found object is to the center of its voxel.
\\
% 
All arrays are implemented as contiguous c-arrays, which are accessible as \name{Numpy}-arrays.
Since these arrays grow with $\mathcal{O}(n^3)$, the aim was to make them movable through the \cpp libraries as well as in \python.
The memory order of the arrays is in $x-y-z$ direction, so the largest memory shift is in $x$ and the smallest in $z$.
This was chosen so that later in the simulation, where light usually travels mainly in $z$-direction, the memory is aligned to the required information and thus the cache prefetcher can be used.
\\
% 
Next, each voxel of those arrays have to be filled with its correct properties.
\\[\baselineskip]
% 
\paragraph{Iteration cycle}
To calculate a discrete volume of optical properties from a fiber configuration, the same fiber representation as in \cref{sec:nerve_fiber_representation} is used, \ie{} a list of lists of 4d coordinates.
The first list inherits nerve fiber bundles.
The second inner list lists the nerve fibers.
Since all objects are \ac{CC}, the problem of discretization can therefore be reduced to the case of a single \ac{CC} object $(\vv{p_i}, \vv{p_{i+1}}, r_i, r_{i+1})$.
% 
To fill the arrays with their information, all voxels of the current \ac{AABB} of the \ac{CC} are iterated over.
For each voxel in the volume of the \ac{AABB} the smallest distance to the line segment of the \ac{CC} is calculated (see \cref{alg:smallDistLinePoint}).
\\
% 
\begin{lstfloat}[!tb]
\lstinputlisting[style=python]{code/short_dist_line_seg_point.py}
\caption[Calculating smallest distance between line segment and point]{Calculating smallest distance and point on line from line segment $p_0, p_1$ to point $q$.}
\label{alg:smallDistLinePoint}
\end{lstfloat}
% 
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.45\textwidth}
\subcaptionbox{\label{fig:vectormodel}vector\_model with microscopic birefringence myelin layer}[.49\textwidth]{
\inputtikz{gfx/simpli/vector_model}} \hfill
\subcaptionbox{\label{fig:fiberLayer}additional fiber layers}[.49\textwidth]{
\inputtikz{gfx/simpli/fiber_layer}}
\caption{Discretisation of fiber with layered properties.}
\label{fig:fiber_discretisation}
\end{figure}
% 
\begin{figure}[!t]
\centering
\def\tikzwidth{0.42\textwidth}
\inputtikz{gfx/simpli/indexing}
\caption{indexing of arrays.
The vector inside the array at index position $[i,j,k]$ will correspond to the vector at position $p=(i+0.5,j+0.5,k+0.5)\cdot \mathit{\voxelsize}$}
\label{fig:indexing_array}
\end{figure}
% 
Using the smallest distance from the current position, the actual physical property of the current fiber segment can be calculated and stored.
Since the birefringent orientation within a fiber can be represented either with the micro- or the maroscopic model (see \dummy{}), the radial or parallel orientation for a point $q$ in the volume (see \cref{fig:vector model}) to the fiber segment must be calculated.
In case of a parallel orientation, the orientation is $o$:
\begin{align}
\begin{split}
    o = \frac{\vv{p}_i - \vv{p}_{i+1}}{\abs{\vv{p}_i - \vv{p}_{i+1}}}
\end{split}
\end{align}
% 
Since a fiber can have multiple layers, \eg{} axon or myelin, the layer must be identified at the  position $q$ (see \cref{fig:fiberLayer}).
This is achieved by comparing the smallest distance from this point to the layer size.
However, since the layer size scales with the fiber radii, it must be taken into account.
This simply means that the current layer is $l$, which satisfies the following condition: 
\begin{align}
    \left(\fiberRadius_i \cdot b + \fiberRadius_{i+1} \cdot(1-b)\right) \cdot \code{layer}_l <= \code{distance} < \left(\fiberRadius_i \cdot b + \fiberRadius_{i+1} \cdot(1-b)\right) \cdot \code{layer}_{l+1} \ 
\end{align}
% 
If a current voxel already has an entry stored, its value within the \code{distance}-array is compared to the current distance.
If the current distance is smaller, the values are overwritten.
This also accounts for the race condition, when two objects take up the same voxel, \eg{} neighboring fiber segments.
At this point all voxels of all fiber segments must be iterated over.
% 
\paragraph{Fiber layers and their properties}
Each nerve fiber bundle needs to be characterized by the corresponding physical parameters.
These parameters are 
\begin{itemize}[nosep]
    \item absorption coefficient $\mu$
    \item birefringence value $\dn$
    \item optical axsis model $p=\mathit{parallel}$, $r=\mathit{radial}$, $b=\mathit{background}$
\end{itemize}
%
\begin{lstfloat}[!tb]
\lstset{style=python}
\begin{lstlisting}[]
fbs_properties = [[(layer, dn, mu, 'p'), (second layer), ...],
                  [(first layer of second bundle), ...],
                  [...]]
\end{lstlisting}
\caption{Definig fiber bundle properties}
\label{alg:fiberbundleprops}
\end{lstfloat}
% 
These parameters must be set for each layer (see \cref{fig:fiberLayer}) within the fiber.
A \code{layer} is a concept that allows the differentiation between axon and myelin or multiple myelin layers with intracellular fluid between the coils (see \cref{fig:fiberLayer}).
This requires the parameters to be set (see \cref{alg:pseudocode_octree}).
% 
The \code{layer} is a factor for how large the proportion of the radius of this layer is.
For example, $\code=0.75$ means that from $0\leq r < 0.75$ of the radii are interpreted as the first layer.
The value can even be set to values $>1$ if the user so wishes.
Of course, a collision-free model is then no longer a guarantee that it is collision-free.
% 
At the end the DV-Generator returns the arrays \tissue{}, \opticalaxis{} and the \propertylist{} for the use of the simulation.
% 
\subsection{optimization}
% 
Two methods are used to parallelize the algorithm on the \ac{CPU}.
The first uses \openmp{} to parallelize the filling of the \ac{AABB} volume of each object.
The second uses \mpi{} to allow distribution to multiple \ac{CPU} cores without sharing memory. 
% 
The parallelization of the \ac{AABB} volume leads to a race condition if several threads want to write to the same memory address (or coordinate) (\eg{} two objects occupy the same space).
A solution with a lock would be very slow.
Since the loop runs over all $(i,j,k)$ indices of the three space dimensions, the parallelization can be done using the indices.
However, this leads to a slow implementation because new threads have to be created for each object.
If was therefore decided, that the parallel call creates all threads before the first loop over all objects.
This means all threads process all objects.
If the threads then execute a loop over all indices (or coordinates), thread $n$ only processes the memory for the first volume dimension $i$ if (see \cref{fig:discVolThread}):
% 
\begin{figure}[!t]
\centering
\setlength{\tikzwidth}{0.5\textwidth}
\inputtikz{gfx/simpli/disc_volume_thread}
\caption{discretisation volume}
\label{fig:discVolThread}
\end{figure}
% 
\begin{align}
\begin{split}
    i \bmod N_{\text{Threads}} == n
\end{split}
\end{align}
% 
This process results in a thread-safe writable operation.
The only drawback is that all threads must check if the \ac{AABB} is inside the \ac{VOI}.
However since with this configuration only once threads are spawned, and the \ac{AABB} collison check is very efficient in terms of computation time, it is quite fast.
\\
% 
For huge volumes that are larger than the locally optimal shared memory size, the calculation must be split into several physical \acp{CPU} or \name{computation nodes}.
For this purpose \mpi{} is used.
A method is implemented that automatically divides the volume along the $x$ axis and $y- axis$ into blocks with minimal surface area.
This is important for the following simulation step (see \cref{sec:simulation}).
Each \mpi{} process can then create a discretized sub-volume as if it were the hole volume.
However, each sub-volume has an additional voxel along the $x$ and $y$ axis for later communication purposes as \name{halo}. (see \cref{sec:simulation}).
Each \mpi{} process can additionally use \openmp{} to create multiple threads for efficient use of shared memory if the architecture supports it.
% 
% 
% 
\section{simulation}
\label{sec:simulation}
% 
\begin{figure}[!t]
\centering
\def\tikzwidth{0.75*\textwidth}
\inputtikz{gfx/simpli/vector_interpolation}
\tikzset{external/export=false}
\caption[Illustration linear and spherical interpolation.]{Illustration of difference between linear and spherical interpolation. Linear interpolation has a constant distance $s$ between each point, spherical interpolation a constant angle $\varphi$ for the same $dt$.}
\label{fig:vectorfield_disc}
\end{figure}
% 
The simulation algorithm executes the M\"uller-Stokes calculus (see \cref{sec:Mueller-Stokes}) on the previously calculated discrete volume (see \cref{sec:dv_generator}) for a light beam along its path.
Since no scattering or refraction effects are included within the tissue volume (except for the effective absorption), each light path follows a straight line.
The interaction of light matter $\left( \prod_i R_i M_i R_i \times \vv{S} \right)$ is calculated. 
After the light beam has reached the end of the tissue, the last optical elements (\eg{} polarizer) are taken into account.
Finally, the light intensity is stored in the resulting \acs{CCD} image array. 
\\
%
The simulation allows a tiltable light beam like the \ac{LAP} setup.
For this purpose, the \ac{LAP} uses a tilting stage to which the tissue sections are attached (see \cref{fig:tilted_side_view}). 
The newly designed microscope on the other hand has a tiltable light beam.
Both methods yield identical light paths.
However, the tiltable specimen leads to a distorted view, visible in the \ac{CCD} images.
This distortion can be described by an affine transformation (see \cref{fig::affine_transformation}):
% 
\begin{figure}[!t]
\centering
\input{gfx/pli/affine_transformation}
\caption{affine transformation}
\label{fig::affine_transformation}
\end{figure}
% 
\begin{align}
f(\vv{x}) = \mat{A} \cdot \vv{x} + \vv{t}
\end{align}
where $\vv{x}$ the coordinate input, $\mat{A}$ and $\vv{t}$ the transformation values and $f(\vv{x}$ the transformed coordinate.
\\
% 
The simulation is able to take the distorted view into account.
This leads to sampled light paths, which in turn are distorted so that the resulting \ac{CCD} image is undistorted.
It is the same as distorting the \ac{CCD} sensor.
However, this does not lead to the same experimental results because the light rays of the sample no longer correspond to the \ac{CCD} sensor.
For this reason, the simulation pipeline supports a distorted view.
To avoid distorting the view, the affine inverse transformation $f^{-1}(\vv{x}) = \mat{A}^{-1} \cdot \vv{x} - \vv{t}$ can be applied.
However, this leads to interpolation artifacts.
This is the reason for the existence of both techniques.
The latter is the same as used within the \ac{LAP} experimental analysis.
\\
% 
The last effect is the refraction of the tissue-air border\footnote{glass adds only a parallel shift} which is simply a Parallax Effect well described by Snell's law for isotropic media:
\begin{align}
\begin{split}
    n_1 \sin{\Theta_1} = n_2 \sin{\Theta_2}
\end{split}
\label{equ:snell}
\end{align}
% 
% To always get the same dens of light rays per ccd-pixel, all light ray starting positions are calculated from the ccd-pixels.
% 
\subsection{algorithm}
% 
\paragraph{calculation of light ray starting position}
% 
\begin{figure}[!t]
\def\tikzwidth{0.42\textwidth}
\subcaptionbox{normal}[.495\textwidth]{
\def\tilt{0}
\def\nindex{2.25}
\inputtikz[true]{gfx/simpli/tilting_a}}\hfill
\subcaptionbox{tilted}[.495\textwidth]{
\inputtikz[true]{gfx/simpli/tilting_b}}
\caption{side view tilting}
\label{fig:tilted_side_view}
\end{figure}
% 
First, the light path of each light beam that hits a \ac{CCD} sensor pixel has to be calculated.
For the trivial case that the sample is not tilted, this is simply the \ac{CCD} pixel centering.\todo{supersampling}
For any type of tilted sample (not only north, south, east and west) the light distortion described above must be taken into account.
Since it is always known where the light paths end in the \ac{CCD} pixel, one can start here and go backwards to the lower level of the tissue section (see \cref{fig:tilted_side_view}).
First the first refraction is calculated, which changes the direction of the light rays from $\vv{l}_0$ to $\vv{l}_1$, which happens in the upper tissue section $\mathfrak{S}_{top}$.
After the light beam $\vv{l}_1$ to plane $\mathfrak{S}_{bottom}$ the intersection is calculated by a simple triangle with the mesh thickness.
This point is the corresponding starting point.
No further crossing of the light beam needs to be calculated, because the optical elements previously only change the polarization state, but not the light position.
Once calculated, the same transformation can be applied to all pixels of the \ac{CCD} sensor.
% 
\begin{figure}[!t]
\def\tikzheight{0.42\textwidth}
\subcaptionbox{camera view}[.49\textwidth]{
\inputtikz{gfx/simpli/tilting_3d_a}}\hfill
\subcaptionbox{perspective view}[.49\textwidth]{
\inputtikz{gfx/simpli/tilting_3d_b}}
\tikzset{external/export=false}
\caption[3d tilting]{3d tilting: around $xy$-axis, \raisebox{.25em}{\tikz \draw[red,thick](0,0)--(0.25,0);} top, \raisebox{.25em}{\tikz \draw[green,thick](0,0)--(0.25,0);} middle, \raisebox{.25em}{\tikz \draw[blue,thick](0,0)--(0.25,0);} bottom, \raisebox{.25em}{\tikz \draw[dash pattern=on 1.25pt off 1.25pt,thick](0,0)--(0.25,0);} original, \raisebox{.25em}{\tikz \draw[gray](0,0)--(0.25,0);} axis of rotation \itodo{test david und daniel}}
\end{figure}
% 
\vspace{5pt}
\hrule
\vspace{6pt}
% 
\newpage
% 
% The simulation uses as input parameter the refraction index of the tissue and the tilting angle to calculate the inner light angle.
% From this the starting position of the light beam can be calculated (see \cref{fig:tilted_side_view}):
% 
First the light ray is backwards traversed starting at each ccd "pixel" (2).
Here the pixel size is equivalent to the voxel size.
Later the camera pixel size will be applied.
The light ray first hits the (tilted) tissue plane (2).
There its path is refrected according to Snells Law (\cref{equ:snell}).
From this the possition of the light at the bottom tissue plane (3) is calculated.
This is also the starting position of the light beam, since previous interactions do not require spatial information (\ie{} pol filter and $\lambda/4$-retarder).\\
% 
The ccd sensor and the tissue volume gets each their own coordinate system.
The ccd-sensor is described as a 2d plane.
The plane is rastered with a grid where each grid cell coresponds to a "pixel".
The light ray starts in the center of each "pixel", therefore a offset of $(\num{0.5}, \num{0.5})$ is added to the coordinate system for the geometric calculation.
The ccd-sensor index will be stored for each light ray in in case of a \mpi{} communication each process knows where to store the light intensity.\\
% 
The tissue coordinate system begins at the first array element with the index $(i=0, j=0, k=0)$.
The volume itself is specified by a dim-variable $(N_x, N_y, N_z)$.
Each voxel takes the space $[(i,j,k),(i+1,j+1,k+1))$ in space.
Therefore there is again a shift of \num{0.5} between the index and the center of each volume voxel.

% 
\paragraph{matrix calculus}
From the starting position the light tissue interaction will be calculated according to $\left( \prod_i R_i M_i R_i \times \vv{S} \right)$ (see \dummy{}).
Since the starting point is at the bottom of the tissue plain, and a light beam takes the step $s$ the physical property from $(x,y,z) + \frac{s}{2}$ is used (ZEICHNUNG).
For a non tilted view with a stept size equal to the voxel size this results in the indices values.
As long the light beam is inside the local (\mpi{}) tissue volume, everything can be calculated.
As soon as the light beam leaves the local volume it will be transfered to the appropriate mpi process.
If a linear interpolation of the properties is needed, the local volume gets in $x$ and $y$ direction an additional voxel.
With this "halo" the neighboring mpi process can also interpolate (with a distance of 1) the value.
Light which leaves the tissue / starts outside the tissue will be calculated with the background property.
% 
If the birefringence is 0 the multiplication of the M\"uller matrices is skipped and only the absorption is taken into account.
Since the M\"uller matrices are spasly (in this case), the calculation is optimized for this.
% 
\begin{lstfloat}[!t]
	\lstinputlisting[style=cpp,basicstyle=\scriptsize\ttfamily,]{code/simulation.cpp}
	\caption{Pseudocode simulation}
	\label{alg:simulation}
\end{lstfloat}
%
% 
\subsection{parallelisation}
There are several optimizations used inside this pipeline.\\
% 
First the order of the tissue stored inside the memory is along the z-axis.
This allows the light for the non tilted case along the z-axis and therfore along the memory.
therefore the data can be transferred linear to the cache and the prefetcher\footnote{A prefetcher get not only the data of the memory address i but also its neighbours i+1 and i-1 (depending on the order).
This means the data is already in cache, if the next step is calculated.
For linear traversions this means effectively a infinitive cache size.} of (modern) \ac{CPU} architectures hits its full potential.
This is also noticeable in the tilted view, since the tilting angle in the \ac{3D-PLI}-experiment is rather small.
This reduces secnificantly the acces time of the \ac{CPU} and the \ac{RAM}.\\
% 
Secondly the main for loop for each light ray is parallized with \openmp{}.
This threads are completely separated and no race conditions exists.\\
% 
Additionally the same mpi topography is used from the DV-Generator (see \cref{sec:dv_generator}).
This is the reason the volume gets split into smaller parts with minimal surface area, since then the number of needed communications is also minimal.
In the previous \simpli{} implementatio the communication was not needed because the halo was as big that the light beam was never leaving the local volume.
This however meant, that for each tilted image the local volume had to be recalculated.
Also the memory consumption was much larger.
This yields in a quite big reduction of processing time. \footnote{so much, that the local memory is the bootlenek, not the cpu power.}\\
% 
At corners the light beam can travel through several \mpi{} volumes.
Therefore after each main loop the ommunication has to be done.
Then the main loop is repeated with all incomming light rays.
When no light rays are communicated anymore, the simulation is finished.
This is a rather small cost considering the saving of memory and for tissue section commenly thin tissue sections of \SI{60}{\micro\meter}.
% 
% 
% \lstinputlisting[language=c++, name=mpi_comm, caption={MPI code simulation}, label={alg:mpi_comm}]{code/mpi_comm.cpp}
% \begin{lstfloat}[!h]
% 	\caption{Pseudocode simulation}
% 	\label{alg:mpi_comm}
% \end{lstfloat}
% 
\itodo{smart sampling sp√¶ter diskutieren}